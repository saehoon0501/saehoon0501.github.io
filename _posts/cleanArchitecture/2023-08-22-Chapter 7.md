---
title: SRP(The Single Responsibility Principle)
date: 2023-08-22 13:10:00 +/-0
categories: [clean_architecture]
tags: [clean_architecture.clean_architecture-chp7] # TAG names should always be lowercase
---

SOLID 원칙을 통해 중간 수준의 소프트웨어 구조가 아래와 같도록 만든다.

- 변경에 유연하다.
- 이해하기 쉽다.
- 많은 소프트웨어에 사용될 수 있는 컴포넌트의 기반이 된다.

SOLID 원칙은 함수와 데이터 구조를 클래스로 배치하는 방법 그리고 이들 클래스를 서로 결합하는 방법을 설명해준다.  
여기서 클래스는 단순히 함수와 데이터를 결합한 집합을 가리키며, 이러한 집합에 SOLID가 적용된다.

잘 만들어진 벽돌로 빌딩의 아키텍처를 완전히 망쳐버릴 수 있듯이, 잘 설계된 중간 수준의 컴포넌트를 이용하더라도 시스템 전체를 엉망진창으로 만들 가능성 또한 존재한다.  
이러한 이유로 먼저 컴포넌트 세계에서의 SOLID 원칙을 설명하고, 이어서 고수준의 아키텍처에서의 원칙을 설명할 것이다.

## SRP: The Single Responsibility Principle

소프트웨어 시스템이 가질 수 있는 최적의 구조는 시스템을 만드는 조직의 사회적 구조에 커다란 영향을 받는다. 그리고 변경을 요청하는 한 명 이상의 사람들을 'Actor'라 부른다.  
이때 **각 소프트웨어 모듈은 단 하나의 Actor에 대해서만 책임져야 한다.**  
여기서 모듈은 단순히 함수와 데이터 구조로 구성된 응집된 집합이다. 단일 Actor를 책임지는 코드를 함께 묶어주는 힘이 바로 응집성이다.

이 원칙을 이해하는데 가장 좋은 방법은 이 원칙을 위반하는 징후들을 살펴보는 것이다.

### 징후 1: 우발적 중복

한 클래스 안에 Actor A,B,C에 대해 서로 다른 메서드를 구현했다고 가정한다.  
그리고 이 서로 다른 메서드에서 중복된 부분 없애기 위해 중복되는 부분을 메서드로 추출하여 공유한다.  
만약 한 Actor에서 요구사항을 변경되어 메서드를 수정하는 과정에서 공유되는 메서드까지 수정되는 경우 다른 Actor를 위한 메서드들까지 수정에 영향을 받게되 문제가 발생한다.  
따라서 서로 다른 Actor가 의존하는 코드를 너무 가까이 배치했기에 발생했기에 서로 다른 Actor가 의존하는 코드를 서로 분리하여야 한다.

### 병합

메서드가 서로 다른 Actor를 책임진다면 병합이 발생할 가능성이 더 높다.  
팀 A와 B에서 사용하는 공통된 클래스에 대해 각각의 요구사항에 맞춰 이를 수정할 경우 이들의 변경사항은 서로 충돌한다. 결과적으로 병합이 발생하는 것이다.  
이를 벗어나는 방법은 서로 다른 Actor를 뒷받침하는 코드를 서로 분리하는 것이다.

### 해결책

아마도 가장 확실한 해결책은 데이터와 메서드를 분리하는 방식일 것이다. 즉, 아무런 메서드가 없는 간단한 데이터 구조인 클래스를 만들어 각 Actor를 뒷받침하는 클래스가 공유하도록 한다. 각 클래스는 자신의 메서드에 반드시 필요한 소스 코드만을 포함한다. 그리고 각 Actor에 대한 클래스는 서로의 존재를 모르면 우연한 중복을 피할 수 있다.  
이 해결책은 개발자가 각 Actor에 대한 클래스를 인스턴스화하고 추척해야 한다는게 단점이다. 이러한 단점을 해결하는 흔한 방법은 Facade Pattern을 활용하는 것이다.

Facade 클래스에서는 각 Actor에 대한 클래스의 객체를 생성하고 요청된 메서드를 가지는 객체로 위임하는 일을 책임진다. 만약 가장 중요한 업무 규칙을 데이터와 가깝게 배치하고 싶을 경우 가장 중요한 메서드는 공유하는 클래스에 그대로 유지하되 덜 중요한 나머지 메서드들에 대해서만 Facade로 사용할 수 있다.

### 결론

SRP는 메서드와 클래스 수준의 원칙이다.  
하지만 이보다 상위의 두 수준인 컴포넌트 수준에서는 공통 폐쇄 원칙(Common Clousre Principle)으로 등장하며, 아키텍처 수준에서는 아키텍처 경계(Architectural Boundary)의 생성을 책임지는 변경의 축으로 등장한다.
