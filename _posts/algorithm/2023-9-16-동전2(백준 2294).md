---
title: 동전2(백준 2294)
date: 2023-09-16 17:10:00 +/-0
categories: [algorithm]
tags: [dynamic programming] # TAG names should always be lowercase
---

## 문제

| 시간 제한 | 메모리 제한 |
| --------- | ----------- |
| 1 초      | 128 MB      |

n가지 종류의 동전이 있다. 이 동전들을 적당히 사용해서, 그 가치의 합이 k원이 되도록 하고 싶다. 그러면서 동전의 개수가 최소가 되도록 하려고 한다. 각각의 동전은 몇 개라도 사용할 수 있다.

사용한 동전의 구성이 같은데, 순서만 다른 것은 같은 경우이다.

### 입력

첫째 줄에 n, k가 주어진다. (1 ≤ n ≤ 100, 1 ≤ k ≤ 10,000) 다음 n개의 줄에는 각각의 동전의 가치가 주어진다. 동전의 가치는 100,000보다 작거나 같은 자연수이다. 가치가 같은 동전이 여러 번 주어질 수도 있다.

### 출력

첫째 줄에 사용한 동전의 최소 개수를 출력한다. 불가능한 경우에는 -1을 출력한다.

## 풀이

금액별로 만들 수 있는 동전 개수의 최소 사용 횟수를 구해야 하며, 중복되는 가치를 가진 동전이 여러 번 주어질 수 있다. 중복되는 경우 결국에는 동전 개수의 최소 사용 횟수를 가지기에 별도로 처리하지 않아도 계산 결과에 영향을 미치지 않고 단지 중복되는 계산 과정을 거치게 된다.  
배열에는 각 금액 별 동전의 최소 사용 횟수를 저장한다.
매번 동전이 주어질 경우 아래 과정을 반복해 수행할 수 있다.

1. 동전의 가치보다 작은 금액에 해당하는 칸은 계산을 수행하지 않는다.
2. 동전의 가치와 같거나 큰 금액에 해당하는 칸에는 [해당 금액 - 동전의 가치]에 해당 하는 칸의 값 + 1과 현재
   존재하는 값을 비교해 더 작은 값으로 업데이트 한다.

위 과정을 반복하면 최종적으로 금액 k에 존재하는 칸의 값을 출력하면 된다.

```python
n, k = map(int, input().split())
dp = [10**5] * (k + 1)

for _ in range(n):
    coin = int(input())
    if coin <= k:
        dp[coin] = 1
        for j in range(coin + 1, k + 1):
            if dp[j - coin] != 10**5:
                dp[j] = min(dp[j - coin] + 1, dp[j])
if dp[k] == 10**5:
    print(-1)
else:
    print(dp[k])
```

## 시간 복잡도

최악의 경우 동전 개수 n마다 약 k번 작업을 수행하기에 10<sup>6</sup>번의 작업을 수행하게 된다.

## 공간 복잡도

배열의 크기를 k만큼 선언하기에 최대 10<sup>4</sup>\*4Byte 의 배열 크기를 사용한다.

## 어려웠던 부분

주어지는 동전의 가치가 k보다 큰 경우를 고려해야 한다.  
만약 고려하지 않을 경우 구현 방법에 따라 indexOutOfRange Error가 발생할 수 있기 때문이다.
또한 최소 사용 횟수를 계산하기에 처음 배열의 값을 초기화할 때 값을 신경써서 선택하여야 정확히 값이 반영된다.  
따라서 이 경우 가장 크게 가질 수 있는 동전 사용 횟수인 10<sup>4</sup>보다 큰 값으로 선택했다.
