---
title: 동전(백준 9084)
date: 2023-09-16 15:10:00 +/-0
categories: [algorithm]
tags: [dynamic programming] # TAG names should always be lowercase
---

## 문제

| 시간 제한 | 메모리 제한 |
| --------- | ----------- |
| 1 초      | 128 MB      |

우리나라 화폐단위, 특히 동전에는 1원, 5원, 10원, 50원, 100원, 500원이 있다. 이 동전들로는 정수의 금액을 만들 수 있으며 그 방법도 여러 가지가 있을 수 있다. 예를 들어, 30원을 만들기 위해서는 1원짜리 30개 또는 10원짜리 2개와 5원짜리 2개 등의 방법이 가능하다.

동전의 종류가 주어질 때에 주어진 금액을 만드는 모든 방법을 세는 프로그램을 작성하시오.

### 입력

입력의 첫 줄에는 테스트 케이스의 개수 T(1 ≤ T ≤ 10)가 주어진다. 각 테스트 케이스의 첫 번째 줄에는 동전의 가지 수 N(1 ≤ N ≤ 20)이 주어지고 두 번째 줄에는 N가지 동전의 각 금액이 오름차순으로 정렬되어 주어진다. 각 금액은 정수로서 1원부터 10000원까지 있을 수 있으며 공백으로 구분된다. 세 번째 줄에는 주어진 N가지 동전으로 만들어야 할 금액 M(1 ≤ M ≤ 10000)이 주어진다.

편의를 위해 방법의 수는 231 - 1 보다 작고, 같은 동전이 여러 번 주어지는 경우는 없다.

### 출력

각 테스트 케이스에 대해 입력으로 주어지는 N가지 동전으로 금액 M을 만드는 모든 방법의 수를 한 줄에 하나씩 출력한다.

## 풀이

1과2의 동전이 주어졌을 때 10을 만드는 경우를 가정하면 아래와 같이 생각할 수 있다.  
처음 1이 주어졌을 때는 모든 금액을 만드는 경우는 1가지다.  
2가 주어졌을 경우

- 2를 만드는 방법은 1+1, 2 이렇게 두 가지다.
- 3을 만드는 방법은 1+1+1, 1+2 이렇게 두 가지다. 이는 기존 1+1+1 방법에 1+2 방법을 추가한 것으로 볼 수 있다. 결국 이는 index가 3인 칸에 index가 1인 칸의 값을 누적한다고 보면 된다.
- 4의 경우 1+1+1+1 방법에 1+1+2, 2+2를 추가한 것으로 볼 수 있고 결국 이는 index가 4인 칸에 index가 2인 칸의 값을 누적한다고 보면 된다.

이를 코드로 나타낸다.  
먼저 주어지는 금액 M 크기의 배열을 선언한다.  
배열에는 각 금액을 index로 만들 수 있는 모든 방법을 저장한다.
동전이 주어질 때마다 해당 동전의 가치에서부터 index를 시작해 M까지 진행하며 아래와 같은 작업을 수행한다.

1. 동전의 가치에 해당하는 칸의 값에 +1을 누적한다.
2. 동전의 가치보다 큰 금액에 칸들의 경우 [동전의 가치보다 큰 금액 - 동전의 가치]에 해당 하는 칸의 값을 더해 누적한다. 아니면 반대로 [주어지는 index + 동전의 가치]에 해당하는 칸에 주어지는 index 칸의 값을 더해 누적할 수 있다.
3. 위 과정을 동전이 주어질 때마다 반복한 후 최종적으로 M금액 칸에 있는 값을 출력한다.

문제에서 같은 동전이 여러 번 주어지는 경우가 없기에 같은 방법이 중복으로 더해지는 경우는 고려할 필요가 없다.

```python
T = int(input())

results = []
for _ in range(T):
    N = int(input())
    coins = list(map(int, input().split()))
    amount = int(input())
    dp = [1] + [0] * (amount)

    for c in coins:
        for i in range(amount + 1):
            if i + c <= amount:
                dp[i + c] += dp[i]
            else:
                break
    results.append(dp[amount])

for result in results:
    print(result)
```

## 시간 복잡도

동전의 가지 수 N의 최대는 20  
금액의 최대 크기 10000  
최악의 경우 배열에 대해 10000번의 계산을 수행할 수 있기에 대략 10000\*20번의 수행을 한다고 가정하면 2\*10<sup>5</sup>의 연산을 할 수 있다. 실제로는 동전의 가치가 1원인 경우는 한번만 주어지기에 이보다 작을 것이다.

## 공간 복잡도

각 금액 별로 만들 수 있는 모든 방법을 하나의 배열에 저장하기에 주어지는 최대 크기인 10000\*4Byte의 배열을 사용하게 될 것이다.

## 어려웠던 부분

계산을 수행하는 과정에서 누적되는 방법의 수는 이전에 업데이트 되었던 값을 가지고와 누적해야 한다.
따라서 배열을 하나만 가지고 계산을 수행할 수 있다. 만약 값을 업데이트하는 과정에서 이전 결과들만을 반영해야 한다면 각 동전마다 배열을 선언하여 업데이트되는 배열과 값을 가지고 오는 배열을 분리해야 될 것이다.
