---
title: 가장 큰 증가하는 부분 수열(백준 11055)
date: 2023-09-17 17:10:00 +/-0
categories: [algorithm]
tags: [dynamic programming] # TAG names should always be lowercase
---

## 문제

| 시간 제한 | 메모리 제한 |
| --------- | ----------- |
| 1 초      | 256 MB      |

수열 A가 주어졌을 때, 그 수열의 증가하는 부분 수열 중에서 합이 가장 큰 것을 구하는 프로그램을 작성하시오.

예를 들어, 수열 A = {1, 100, 2, 50, 60, 3, 5, 6, 7, 8} 인 경우에 합이 가장 큰 증가하는 부분 수열은 A = {1, 100, 2, 50, 60, 3, 5, 6, 7, 8} 이고, 합은 113이다.

### 입력

첫째 줄에 수열 A의 크기 N (1 ≤ N ≤ 1,000)이 주어진다.

둘째 줄에는 수열 A를 이루고 있는 Ai가 주어진다. (1 ≤ Ai ≤ 1,000)

### 출력

첫째 줄에 수열 A의 합이 가장 큰 증가하는 부분 수열의 합을 출력한다.

## 풀이

dp에 사용되는 배열에는 해당 칸에 존재하는 숫자를 반드시 포함하는 가장 큰 증가하는 부분 수열의 합을 저장한다.  
따라서 만약 i번째 칸에서 계산을 수행한다면 이전 칸들을 보면서 i번째 칸보다 값이 작은 숫자들 위치에 저장된 합 결과들 중 가장 큰 값 + i번째 수를 저장하게 된다.  
최종적으로 저장된 dp 전체에서 저장된 값 중 최대 값을 가져오면 된다.

```python
A = int(input())
numbers = list(map(int, input().split()))
dp = [0] * A

dp[0] = numbers[0]
for i in range(1, A):
    dp[i] = numbers[i]
    for j in range(i):
        if numbers[j] < numbers[i]:
            dp[i] = max(dp[i], dp[j] + numbers[i])
print(max(dp))

```

## 시간 복잡도

배열의 칸마다 이전 칸들을 끝까지 지나가며 계산을 수행하기에 O(N<sup>2</sup>)의 결과가 나오게 된다.

## 공간 복잡도

A의 크기의 공간을 사용하게 된다.

## 어려웠던 부분

배열에 각 칸에 저장되는 값은 반드시 해당 숫자를 포함하는 최대 증가하는 부분 수열의 합을 이용하는 아이디어를 떠올릴 수만 있다면 어렵지 않은 문제였다.
