---
title: 상속 다루기
date: 2023-08-18 18:10:00 +/-0
categories: [refactoring]
tags: [refactoring, inheritance] # TAG names should always be lowercase
---

Refactoring Github  
<https://github.com/saehoon0501/Refactoring>

OOP에서 가장 유명한 특성인 상속을 다룬다. 상속은 발등에 불이 떨어져서야 비로소 잘못 사용했음을 알아차리는 경우가 많다.

나오는 기법들:

- 메서드 올리기
- 필드 올리기
- 생성자 본문 올리기
- 메서드 내리기
- 필드 내리기
- 타입 코드를 서브클래스로 바꾸기
- 서브클래스 제거하기
- 슈퍼클래스 추출하기
- 계층 합치기
- 서브클래스 위임으로 바꾸기
- 슈퍼클래스를 위임으로 바꾸기

### 메서드 올리기

배경  
서브 클래스에 메서드들의 본문 코드가 똑같은 경우 가장 쉬운 상황으로 그냥 메서드를 복사해 슈퍼클래스에 붙여넣으면 끝이다. 그리고 테스트를 통해 얼마나 잘 만들었느냐에 크게 의존하기에 차이점을 찾는 방법이 효과가 가장 좋다.
하지만 대부분 선행 단계를 거쳐야 할 때가 많다. 서브클래스의 메서드를 각각 매개변수화하면 궁극적으로 같은 함수가 되기도 한다. 가장 복잡한 상황은 메서드의 본문에서 참조하는 필드들이 서브클래스에만 있는 경우이다. 이런 경우라면 필드를 먼저 슈퍼클래스로 올린 후에 메서드를 올려야 한다.

만약 메서드의 전체 흐름은 비슷하지만 세부 내용이 다르다면 템플릿 메서드 만들기를 고려해본다.  
절차

1. 똑같이 동작하는 메서드인지 면밀히 살펴본다.
   실질적으로 하는 일은 같지만 코드가 다르다면 본문 코드가 똑같아질 때까지 Refactoring한다.
2. 메서드 안에서 호출하는 다른 메서드와 참조하는 필드들을 슈퍼클래스에서도 호출하고 참조할 수 있는지 확인한다.
3. 메서드 시그니처가 다르다면 함수 선언 바꾸기로 슈퍼클래스에서 사용하고 싶은 형태로 통일한다.
4. 슈퍼클래스에 새로운 메서드를 생성하고 대상 메서드의 코드를 복사해넣는다.
5. 정적 검사를 수행
6. 서브클래스 중 하나의 메서드를 제거한다.
7. 테스트
8. 모든 서브클래스의 메서드가 없어질 때까지 다른 서브클래스의 메서드를 하니씩 제거한다.

### 필드 올리기

배경  
서브클래스들이 독립적으로 개발되었거나 뒤늦게 하나의 계층구조로 Refactoring된 경우라면 일부 기능 특히 필드가 중복되기 쉽다.(이름은 다르지만 동일한 목적으로 사용될 수 있다.)
결과적으로 해당 Refactoring을 통해 데이터 중복 선언과 필드를 사용하는 동작을 서브클래스에서 슈퍼클래스로 옮길 수 있다.

만약 동적 언어 중 필드를 클래스 정의 포함시키지 않는 경우 생성자 본문부터 올리자.  
절차

1. 후보 필드들을 사용하는 곳 모두가 그 필드들을 똑같은 방식으로 사용하는지 면밀히 살핀다.
2. 필드들의 이름이 각기 다르다면 똑같은 이름으로 바꾼다.(필드 이름 바꾸기)
3. 슈퍼클래스에 새로운 필드를 생성한다.
   서브클래스에서 이 필드에 접근할 수 있어야 한다.(대부분 언어에서는 protected로 선언하면 된다.)
4. 서브클래스의 필드를 제거한다.
5. 테스트

### 생성자 본문 올리기

배경  
만약 서브클래스들에서 기능이 같은 메서드를 찾았는데 생성자라면 기존 올리기 방법과 다른 접근을 해야 한다.
만약 이번 Refactoring이 간단히 끝날 것 같지 않다면 생성자를 Factory함수로 바꾸기를 고려한다.  
절차

1. 슈퍼클래스에 생성자가 없다면 하나 정의한다. 서브클래스의 생성자들에서 이 생성자 호출되는지 확인한다.
2. 문장 슬라이드하기로 공통 문장 모두 super() 호출 직후로 옮긴다.
3. 공통 코드를 슈퍼클래스에 추가하고 서브클래스들에서는 제거한다. 생성자 매개변수 중 공통 코드에서 참조하는 값들을 모두 super()로 건넨다.
4. 테스트
5. 생성자 시작 부분으로 옮길 수 없는 공통 코드에는 함수 추출하기와 메서드 올리기를 차례로 적용한다.

### 메서드 내리기

배경  
이 Refactoring은 서브클래스가 정확히 무엇인지를 호출자가 파악하여 특정 서브클래스와만 관련된 메서드를 슈퍼클래스에서 제거하고 해당 서브클래스에 추가하는 것이다. 만약 그렇지 못한 상황이라면 슈퍼클래스의 메서드를 다형성으로 서브클래스에서 구현해야 한다.  
절차

1. 대상 메서드를 모든 서브클래스에 복사한다.
2. 슈퍼클래스에서 그 메서드를 제거한다.
3. 테스트
4. 이 메서드를 사용하지 않는 모든 서브클래스에서 제거한다.
5. 테스트

### 필드 내리기

배경  
서브클래스 하나(혹은 소수)에서만 사용하는 필드는 해당 서브클래스로 옮긴다.  
절차

1. 대상 필드를 모든 서브클래스에 정의한다.
2. 슈퍼클래스에서 그 필드를 제거한다.
3. 테스트
4. 이 필드를 사용하지 않는 모든 서브클래스에서 제거한다.
5. 테스트

### 타입 코드를 서브클래스로 바꾸기

배경  
시스템에서는 비슷한 대상들을 특정 특성에 따라 구분해야 할 때가 있다. ex) 담당 업무, 직급
이런 일을 다루는 수단으로 타입 코드 필드가 있다. 타입 코드는 프로그래밍 언어에 따라 열거형이나 심볼, 문자열, 숫자 등으로 표현하며, 외부 서비스가 제공하는 데이터를 다루려 할 때 딸려오는 일이 흔하다.
만약 타입 코드 그 이상의 무언가가 필요할 때 서브클래스를 통해 조건에 따라 다르게 동작하게 해주는 다형성과 특정 타입에서만 의미있는 값을 사용하는 필드나 메서드를 구현할 수 있다. 그리고 이러한 방식이 관계를 더 명확히 드러내준다.

이번 Refactoring은 대상 클래스에 적용할지 타입 코드 자체에 적용할지 고민해야 하는데 대상 클래스를 직접 서브클래싱하는게 간단하지만 업무 유형을 다른 용도로도 쓰고 싶을 때 그럴 수 없고(서로 다른 용도로 다형성을 사용하면 관계가 꼬임) 유형이 불변일 때도 직접 서브클래싱 방식은 사용할 수 없다. 이럴 때 서브클래싱 대상을 직원 유형 속성에 적용하고자 한다면 먼저 타입 코드에 '기본형을 객체로 바꾸기'를 적용하여 직원 유형 클래스를 만든 후 해당 Refactoring을 적용하면 된다.  
절차

1. 타입 코드 필드를 자가 캡슐화 한다.
2. 타입 코드 값 하나를 선택하여 그 값에 해당하는 서브클래스를 만든다. 타입 코드 게터 메서드를 오버라이드하여 해당 타입 코드의 리터럴 값을 반환하게 한다.
3. 매개변수로 받은 타입 코드와 방금 만든 서브클래스를 Mapping하는 선택 로직을 만든다.
   직접 상속일 때는 생성자를 Factory함수로 바구기를 적용하고 선택 로직을 Factory에 넣는다. 간접 상속(파생된 클래스를 상속하는 경우)일 때는 선택 로직을 생성자에 두면 될 것이다.
4. 테스트
5. 타입 코드 값 각각에 대해 서브클래스 생성과 선택 로직 추가를 반복한다. 클래스 하나가 완성될 때마다 테스트
6. 타입 코드 필드를 제거한다.
7. 테스트
8. 타입 코드 접근자를 이용하는 메서드 모두에 메서드 내리기와 조건부 로직을 다형성으로 바꾸기를 적용한다.

### 서브클래스 제거하기

배경  
시간이 지나면서 서브클래스로 만든 다형성이 다른 모듈로 이동하거나 가치가 바래기도 한다. 그래서 이제 서브클래스가 더 이상 쓰이지 않으면 이를 제거한다.  
절차

1. 서브클래스의 생성자를 Factory함수로 바꾼다.
   생성자를 사용하는 측에서 데이터 필드를 이용해 어떤 서브클래스를 생성할지 결정한다면 그 결정 로직을 슈퍼클래스의 Factory 메서드에 넣는다.
2. 서브클래스의 타입을 검사하는 코드가 있다면 그 검사 코드에 함수 추출하기와 함수 옮기기를 차례로 적용하여 슈퍼클래스로 옮긴다. 하나 변경할 때마다 테스트
3. 서브클래스의 타입을 나타내는 필드를 슈퍼클래스에 만든다.
4. 서비클래스를 참조하는 메서드가 방금 만든 타입 필드를 이용하도록 수정한다.
5. 서브클래스를 지운다.
6. 테스트

### 슈퍼클래스 추출하기

배경  
비슷한 일을 수행하는 두 클래스가 보이면 상속 메커니즘을 이용해서 비슷한 부분을 공통의 슈퍼클래스로 옮겨 담을 수 있다. 공통된 부분이 데이터라면 필드 올리기를 활용하고, 동작이라면 메서드 올리기를 활용하면 된다.
이러한 상속은 프로그램이 성장하면서 깨우쳐가게 되며, 슈퍼클래스로 끌어올리고 싶은 공통 요소를 찾았을 때 수행하는 사례가 잦다.

슈퍼클래스 추출하기는 중복 동작을 상속으로 해결하는 것이며, 대안으로 '클래스 추출하기'는 중복 동작을 위임으로 해결하는 것이다. 보통 슈퍼클래스 추출하기가 간단한 경우가 많고 나중에 슈퍼클래스를 위임으로 바꾸기는 어렵지 않기에 이를 먼저 해볼 것을 추천한다.  
절차

1. 빈 슈퍼클래스를 만든다. 원래의 클래스들이 새 클래스를 상속하도록 한다.
   필요하다면 생성자에 함수 선언 바꾸기를 적용한다.
2. 테스트
3. 생성자 본문 올리기, 메서드 올리기, 필드 올리기를 차례로 적용하여 공통 원소를 슈퍼클래스로 옮긴다.
4. 서브클래스에 남은 메서드를 검토한다. 공통되는 부분이 있다면 함수로 추출한 다음 메서드 올리기를 적용한다.
5. 원래 클래스들은 사용하는 코드를 검토하여 슈퍼클래스의 인터페이스를 사용하게 할지 고민해본다.

### 계층 합치기

배경  
클래스 계층구조를 Refactoring 하다 보면 기능들을 위로 올리거나 아래로 내리는 일은 다반사다.
계층구조도 진화하면서 어떤 클래스와 그 부모가 너무 비슷해져서 더는 독립적으로 존재해야 할 이유가 사리지는 경우가 생기기도 한다. 바로 그 둘을 하나로 합쳐야 할 시점이다.  
절차

1. 두 클래스 중 제거할 것을 고른다.
   미래를 생각하여 더 적합한 이름의 클래스를 남기자. 둘다 적절치 않다면 임의로 하나를 고른다.
2. 필드 올리기와 메서드 올리기 혹은 필드 내리기와 메서드 내리기를 적용하여 모든 요소를 하나의 클래스로 옮긴다.
3. 제거할 클래스를 참조하던 모든 코드가 남겨질 클래스를 참조하도록 고친다.
4. 빈 클래스를 제거한다.
5. 테스트

### 서브클래스 위임으로 바꾸기

배경  
상속의 가장 명확한 단점은 한 번만 쓸 수 있는 카드라는 것이다. 무언가가 달라져야 하는 이유가 여러 개여도 상속에서는 그중 단 하나의 이유만 선택해 기준으로 삼을 수 밖에 없다. 또한 상속은 클래스들의 관계를 아주 긴밀하게 결합한다. 그래서 자식들이 슈퍼클래스를 어떻게 상속해 쓰는지 이해해야 한다.

위임은 두 문제를 모두 해결해준다. 다양한 클래스에 일반적인 관계를 위임을 통해 상호작용에 필요한 인터페이스를 명확히 정의할 수 있다. 즉, 상속보다 결합도가 훨씬 약하다. 그래서 서브클래싱 관련 문제에 직면하게 되면 흔히 서브클래스를 위임으로 바꾸곤 한다. "Favor composition over inheritance"라는 말과 같이 위임은 composition과 사실상 같은 말이다.
처음에 상속으로 접근해고 안되면 나중에 위임으로 갈아탈 수 있기에 이러한 접근 방식을 권한다.  
절차

1. 생성자를 호출하는 곳이 많다면 생성자를 Factory함수로 바꾼다.
2. 위임으로 활용할 빈 클래스를 만든다. 이 클래스의 생성자는 서브클래스에 특화된 데이터를 전부 받아야 하며, 보통은 슈퍼클래스를 가리키는 역참조도 필요하다.
3. 위임을 저장할 필드를 슈퍼클래스에 추가한다.
4. 서브클래스 생성 코드를 수정하여 위임 Instance를 생성하고 위임 필드에 대입해 초기화한다.
   이 작업은 Factory함수가 수행한다. 혹은 생성자가 정확한 위임 인스턴스를 생성할 수 있는게 확실하다면 생성자에서 수행할 수도 있다.
5. 서브클래스의 메서드 중 위임 클래스로 이동할 것을 고른다.
6. 함수 옮기기를 적용해 위임 클래스로 옮긴다. 원래 메서드에서 위임하는 코드는 지우지 않는다.
   이 메서가 사용하는 원소 중 위임으로 옮겨야 하는게 있다면 함께 옮긴다. 슈퍼클래스에 유지해야 할 원소를 참조한다면 슈퍼클래스를 참조하는 필드를 위임에 추가한다.
7. 서브클래스 외부에도 원래 메서드를 호출하는 코드가 있다면 서브클래스의 위임 코드를 슈퍼클래스로 옮긴다. 이때 위임이 존재하는지를 검사하는 보호 코드로 감싸야 한다. 호출하는 외부 코드가 없다면 원래 메서드는 '죽은 코드 제거하기'한다.
   서브클래스가 둘 이상이고 서브클래스들에서 중복이 생겨나기 시작했다면 슈퍼클래스를 추출한다. 이렇게 하여 기본 동작이 위임 슈퍼클래스로 옮겨졌다면 슈퍼클래스의 위임 메서들에는 보호코드가 필요 없다.
8. 테스트
9. 서브클래스의 모든 메서드가 옮겨질 때까지 5~8과정을 반복한다.
10. 서브클래스들의 생성자를 호출하는 코드를 찾아서 슈퍼클래스의 생성자를 사용하도록 수정한다.
11. 테스트
12. 서브클래스를 삭제한다.

### 슈퍼클래스를 위임으로 바꾸기

배경  
제대로 된 상속이라면 서브클래스가 슈퍼클래스의 모든 기능을 사용함은 물론, 서브클래스의 인스턴스를 슈퍼클래스의 인스턴스로도 취급할 수 있어야 한다. 이렇지 못하다면 위임을 이용해 기능 일부만 빌려오고 서로 별개인 개념을 명확히 한다.

자바에서 스택 클래스는 슈퍼클래스로 리스트를 사용하지만 스택에서는 리스트의 메서드를 그다지 활용하지 않는다. 이런 경우가 바로 슈퍼클래스를 상속하는 대신 위임으로 바꿔 사용하고자 하는 기능 몇가지를 전달함수로 만들어서 사용하면 되는 적절한 사례이다.  
절차

1. 슈퍼클래스 객체를 참조하는 필드를 서브클래스에 만든다.(이번 Refactoring을 마치면 슈퍼클래스가 위임 객체가 될 것이므로 이 필드를 '위임 찾모'라 부르자.) 위임 참조를 새로운 슈퍼클래스 인스턴스로 초기화한다.
2. 슈퍼클래스의 동작 각각에 대응하는 전달 함수를 서브클래스에 만든다(물론 위임 참조로 전달한다.) 서로 관련된 함수끼리 그룹으로 묶어 진행하며, 그룹을 하나씩 만들 때마다 테스트
   대부분은 전달 함수 각각을 테스트할 수 있을 것이다. 하지만 예컨대 getter와 setter 쌍은 둘다 옮긴 후에야 테스트할 수 있다.
3. 슈퍼클래스의 동작 모두가 전달 함수로 override되었다면 상속 관계를 끊는다.
