---
title: OOP
date: 2023-08-21 19:10:00 +/-0
categories: [clean_architecture]
tags: [clean_architecture.clean_architecture-chp5] # TAG names should always be lowercase
---

## Object-Oriented Programming

캡슐화(Encapsulation), 상속(Inheritance), 다형성(Polymorphism)  
이 3가지를 통해 OO가 아키텍처에서 가지는 의미를 알아보자.

### 캡슐화(Encapsulation)

OO가 아닌 언어에서도 충분히 가능하다.(C언어에서 hearder filed 안에는 선언만 하고 구현 파일에서 선언할 것들을 구현하면 그게 캡슐화이다.)  
오히려 OO에서는 클래스 선언과 정의를 구분하는게 불가능하기에 캡슐화를 거의 강제하지 않아 완벽한 캡슐화를 약화시켰다고 볼 수 있다.

### 상속(Inheritance)

이 또한 OO가 아닌 언어에서 가능하다.(새로운 구조체 이름과 메서드를 작성 후 구조체에 기존에 선언된 구조체를 강제 타입 변환하여 사용하면 된다.)  
그나마 OO에서는 upcasting을 상당히 편리한 방식으로 제공했다는 점에서 조금의 점수를 줄 수 있다.

### 다형성(Polymorphism)

이전에는 함수 포인터를 이용해 이를 구현하였지만 만약 포인터를 통해 모든 함수를 호출하는 관례를 프로그래머에게 의존해야 했기에 불안전했다.  
OO에서는 더욱 안전한 방식을 제공하여 다형성이 대수롭지 않은 일이 되도록 한다. 따라서 OO는 제어흐름을 간접적으로 전환하는 규칙을 부과한다고 볼 수 있다.

그러면 다형성이 뭐가 그렇게 좋은가?  
만약 다형성을 통해 복사 프로그램이 새로운 장비에서 작동하도록 하면 복사 프로그램을 수정하지 않아도 된다.  
왜냐하면 복사 프로그램의 소스 코드는 입출력 드라이버의 소스 코드에 의존하지 않기 때문이다. 즉, 입출력 드라이버는 복사 프로그램의 plugin이 된 것이다.  
**즉 OO 언어가 다형성을 안전하고 편리하게 제공한다는 사실은 소스 코드 의존성을 어디에서든 역전시킬 수 있다는 뜻이며 이를 Dependency Inversion라 한다.**

### 의존성 역전(Dependency Inversion)

다형성 이전 소프트웨어는 호출 Tree를 보면 고수준 함수 -> 중간 수준 함수 -> 저수준 함수의 제어 흐름(flow of control)을 따랐다. 그리고 소스 코드 의존성도 이러한 제어 흐름에 따라 결정되었다.  
하지만 다형성을 이용하면 더 이상 **소스 코드 의존성이 제어 흐름을 따라가지 않고 의존성 역전이 일어날 수 있다.**  
만약 모듈 A가 Interface에 대한 소스 코드 의존성을 가지고 모듈 B로 제어 흐름을 가진다고 봤을 때, 모듈 B에서는 이 Interface에 대한 소스 코드 의존성을 가지고 구현하게 된다.(의존성 역전) 그리하면 A에서는 B와 상관없이 독립적인 코드로 존재할 수 있고 원하면 언제든 모듈 B를 다른 모듈로 교체할 수 있다.

이제 소스 코드 의존성이 제어흐름의 방향과 일치되도록 제한되지 않는다. 호출하든 호출 받든 원하는 방향으로 소스 코드 의존성을 설정할 수 있다.  
**이것이 Architect 관점에서 OO가 제공하는 진정한 힘이자 지향하는 것이다.**

### 결론

OO란 무엇인가? 라는 질문의 소프트웨어 아키텍트 관점에서 정답은 명백하다.  
**OO란 다형성을 이용하여 전체 시스템의 모든 소스 코드 의존성에 대한 절대적인 제어 권한을 획득할 수 있는 능력이다.**  
**OO를 사용하면 아키텍트는 plugin 아키텍처를 구성할 수 있고, 이를 통해 고수준의 정책을 포함하는 모듈은 저수준의 세부사항을 포함하는 모듈에 대해 독립성을 보장할 수 있다.**
