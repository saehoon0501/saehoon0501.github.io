---
title: OCP(The Open-Closed Principle)
date: 2023-08-22 14:10:00 +/-0
categories: [clean_architecture]
tags: [clean_architecture.clean_architecture-chp8] # TAG names should always be lowercase
---

## OCP: The Open-Closed Principle

개방-폐쇄 원칙이란  
**소프트웨어 개체(artifact)는 확장에는 열려 있어야 하고, 변경에는 닫혀 있어야 한다.**

다시 말해 확장하는 행위는 가능해야하지만, 변경해서는 안된다.  
소프트웨어 아키텍처를 공부하는 가장 근본적인 이유가 바로 이 때문이다. 만약 요구사항을 살짝 확장하는 데 소프트웨어를 엄청나게 수정해야 한다면, 그 소프트웨어 시스템을 설계한 아키텍트는 엄청난 실패를 맞닥뜨린 것이다.  
이 원칙은 클래스와 모듈을 설계할 때 도움되는 것이라 알고 있지만 컴포넌트 수준에서 고려할 때 훨씬 중요한 의미를 가진다.

### 사고 실험(Thought experiment)

단일 책임 원칙에 따라 서로 다른 목적으로 변경되는 요소를 적절하게 분리하고, DIP에 따라 이들 요소 사이의 의존성을 체계화함으로써 변경량을 최소화 할 수 있다.  
책임을 분리했다면, 분리된 책임들 중 하나에서 변경이 발생하더라도 다른 하나는 변경되지 않도록 소스 코드 의존성도 확실히 조직화 해야한다는 것이다.

모든 컴포넌트 관계는 보호하려는 컴포넌트를 단방향으로 향하도록 이뤄진다.  
만약 A 컴포넌트에서 발생한 변경으로부터 B를 보호하려면 반드시 A 컴포넌트가 B에 의존해야 한다는 것이다.

아키텍처 수준에서 OCP가 동작하는 방식은 기능을 how,why,when에 따라서 분리하고 분리한 기능을 컴포넌트의 계층구조로 조직화한다.  
이러한 계층구조는 '수준(level)'이라는 개념을 바탕으로 생성되며, 가장 높은 수준의 개념은 최고의 보호를 받고 가장 낮은 수준의 개념은 거의 보호 받지 못한다.  
그리고 이러한 저수준 컴포넌트에서 발생한 변경으로부터 고수준 컴포넌트를 보호할 수 있어야한다. 즉 저수준 컴포넌트가 고수준 컴포넌트에 대해 의존해야 한다.

### 방향성 제어

컴포넌트 간 의존성이 제대로 된 방향으로 향하고 있음을 확인하기 위해서는 의존성이 제대로 된 방향으로 가고 있는지 확인한다.  
만약 가장 중요한 Business Rule이 다른 컴포넌트에 의존성을 가지고 있다면 DIP 원칙에 따라 이 의존성을 역전시켜야 한다.

### 정보 은닉

때로는 Interface를 단순히 DIP을 위해서만 사용하는 것이 아닌 정보를 은닉하기 위해서도 사용한다.  
이를 통해 만약 A가 B에 의존하고 B가 C에 의존한다면 A는 C에 의존하게 되는 추이 종속성을 없앨 수 있다.  
소프트웨어 Entity는 '자신이 직접 사용하지 않는 요소에는 절대로 의존해서는 안 된다'라는 원칙을 가지고 있기에 추이 종송석은 이를 위반하게 된다.

고수준의 컴포넌트를 보호하는 것이 우선순위가 가장 높지만 반대로 그에 의존하는 상대적으로 저수준 컴포넌트를 고수준에서의 변화로부터 보호되기를 바라기에 고수준에 대한 정보를 저수준으로부터 은닉한다.

### 결론

OCP의 목표는 시스템을 확장하기 쉬운 동시에 변경으로 인해 시스템이 너무 많은 영향을 받지 않도록 하는데 있다.  
이러한 목표를 위해

- 시스템을 컴포넌트 단위로 분리한다.
- 저수준 컴포넌트에서 발생한 변경으로부터 고수준 컴포넌트를 보호할 수 있는 형태의 의존성 계층구조가 만들어지게 한다.
