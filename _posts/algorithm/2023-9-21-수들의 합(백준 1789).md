---
title:
date: 2023-09-21 12:10:00 +/-0
categories: [algorithm]
tags: [greedy] # TAG names should always be lowercase
---

## 문제

| 시간 제한 | 메모리 제한 |
| --------- | ----------- |
| 2 초      | 128 MB      |

서로 다른 N개의 자연수의 합이 S라고 한다. S를 알 때, 자연수 N의 최댓값은 얼마일까?

### 입력

첫째 줄에 자연수 S(1 ≤ S ≤ 4,294,967,295)가 주어진다.

### 출력

첫째 줄에 자연수 N의 최댓값을 출력한다.

## 풀이

주어지는 S에 대한 값을 나열하여 최대 N을 계산해보면 특정 구간에 포함되는 값들은 모두 같은 N을 가지는 것을 알 수 있다.  
1의 경우 1  
2의 경우 1  
3의 경우 2  
4의 경우 2  
5의 경우 2  
6(1+2+3)의 경우 ~ 9의 경우 3  
10(1+2+3+4)의 경우 ~ 14의 경우 4  
15(1+2+3+4+5)의 경우 ~ 20의 경우 5

이러한 방식으로 구간을 볼 수 있다.
따라서 각 구간 별로 N의 값을 미리 계산하여 저장 후 주어지는 자연수 S가 어느 구간에 존재하는지 계산하여 이에 해당하는 값을 출력하면 된다.

```python
a = []
i = 1
sum = 1

while sum <= 4_294_967_295:
    a.append([sum, i])
    i += 1
    sum += i
a.append([sum, i])

s = int(input())

j = 0
while a[j][0] <= s:
    j += 1

print(a[j - 1][1])

```

## 시간 복잡도

항상 최대 값에 대해 계산하기에 92681번의 구간 계산이 수행된다.  
그리고 주어지는 S가 어느 구간에 존재하는지 계산하기 위해 최대 92681번 계산이 수행될 수 있다.

## 공간 복잡도

2차원 배열을 92681 크기로 만들기에 2\*92681가 나오게 된다.

## 어려웠던 부분

N의 값이 구간 별로 정해진다는 규칙을 찾아내면 별다른 어려움이 없는 문제이다.
