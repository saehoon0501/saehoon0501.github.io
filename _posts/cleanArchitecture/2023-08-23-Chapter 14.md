---
title: Component Coupling
date: 2023-08-23 17:10:00 +/-0
categories: [clean_architecture]
tags: [clean_architecture.clean_architecture-chp14] # TAG names should always be lowercase
---

## Component Coupling

컴포넌트 사이의 관계에 대한 3가지 원칙에 대해 알아본다.  
이전 Chapter와 같이 개발성과 논리적 설계 사이의 균형을 다룬다.

- ADP: Acyclic Dependencies Principle(의존성 비순환 원칙)
- SDP: Stable Dependencies Principle(안정된 의존성 원칙)
- SAP: Stable Abstraction Principle(안정된 추상화 원칙)

### ADP

**컴포넌트 의존성 그래프에 순환(Cycle)이 있어서는 안 된다.**

어느 컴포넌트에서 시작하더라도, 의존성 관계를 따라가면서 최초의 컴포넌트로 되돌아갈 수 없다. 즉 DAG(Directed Acyclic Graph)이다.  
따라서 개발자는 어떤 컴포넌트를 테스트하고자 할 때, 단순히 의존성을 가지는 컴포넌트들에 대해서만 자체 버전을 빌드하면 된다.

하지만 만약 순환이 존재하다면 순환을 이루는 컴포넌트 중 어느 것을 개발하더라도 모두 항상 정확하게 동일한 릴리스를 사용해야 하는 거대한 컴포넌트이기 때문에 간단한 단위 테스트를 실행하는 데도 많은 작업물들을 포함해야 한다. 그리고 빌드 관련 이슈가 무수히 증가한다.  
뿐만 아니라 의존성 그래프에 순환이 생기면 컴포넌트를 어떤 순서로 빌드해야 올바를지 파악하는 순서라는 것 자체가 없을 수 있다.

이러한 컴포넌트 의존성 순환을 다시 DAG로 복구시키는데 2가지 주요 메커니즘이 존재한다.

- Interface를 생성하여 DIP를 적용해 순환을 끊는다.
- 순환 컴포넌트 모두 의존하는 새로운 컴포넌트를 만들고 의존하는 모든 클래스들을 새로운 컴포넌트로 이동시킨다.

두번째 메커니즘에서 시사하는 바는 요구사항이 변경되면 컴포넌트 구조도 변경될 수 있다는 사실이다. 따라서 의존성 구조는 app이 성장함에 다라 서서히 흐트러질 수 있기에 의존성 구조에 순환이 발생하는지를 항상 관찰한다. 그리고 이를 발견했다면 위 2가지 메커니즘을 사용하자.

### Top-Down 설계

컴포너틑 구조는 Top-Down 방식으로 설계 될 수 없다. 오히려 시스템이 성장하고 변경될 때 함께 진화한다.  
사실 컴포넌트 의존성 다이어그램은 app의 기능을 기술하는 일과 거의 관련 없으며, app의 buildability(빌드성)과 유지보수성(maintainability)를 보여주는 지도와 같다. 바로 이러한 이유 때문에 컴포넌트 구조는 프로젝트 초기에 설계할 수 없다.

app이 성장함에 따라 재사용 가능한 요소를 만드는 일에 관심을 기울이기 시작하고 컴포넌트를 조합하는 과정에 CRP가 영향을 미치지 시작한다. 그러다 순환을 발견하면 ADP가 적용되고 이러면서 컴포넌트 의존성 다이어그램은 조금씩 흐트러지고 또 성장하게 되는 것이다.

### SDP

**더 안정된 쪽으로 의존하라**

안정성은 변경을 만들기 위해 필요한 작업량과 관련된다. 즉 안정적인 컴포넌트는 수정에 필요한 작업량이 많이 요구된다.  
이러한 안전성은 컴포넌트 안쪽으로 들어오는 의존성이 많아지면 증가하게 된다. 사소한 변경이라도 의존하는 모든 컴포넌트를 만족시키면서 변경하려면 상당한 노력이 들기 때문이다.

이러한 안정성을 지표로 계산해 나타낼 수 있다.

- Fan-in: 안으로 들어오는 의존성, 컴포넌트 내부의 클래스에 의존하는 컴포넌트 외부 클래스의 개수
- Fan-out: 바깥으로 나가는 의존성, 컴포넌트 외부의 클래스에 의존하는 컴포넌트 내부 클래스의 개수
- I(불안정성): I = Fan-out / (Fan-in + Fan-out), 0이면 최고로 안정 1이면 최고로 불안정한 컴포넌트이다.

이는 import구문과 완전한 클래스 이름의 개수를 세어서 계산해볼 수 있다.

I=1이면 자신에게 의존하는 컴포넌트가 없기에 변경하지 말아야할 이유가 없다.  
I=0이면 자신이 의존하는 컴포넌트가 없으며, 자신을 의존하는 컴포넌트는 있기에 변경하기가 어렵지만, 변경하도록 강제하는 의존성은 없다.  
SDP에서는 I 지표는 그 컴포넌트가 의존하는 다른 컴포넌트들의 I보다 더 커야한다고 한다.  
**즉, 의존성 방향으로 갈수록 I 지표값이 더 작아져야 한다.**

#### 모든 컴포넌트가 안정적이어야 하는 것은 아니다.

컴포넌트 구조를 설계할 때 기대하는 것은 불안정한 컴포넌트도 있고 안정된 컴포넌트도 존재하는 상태이다.
다이어그램에서 불안정한 컴포넌트를 관례적으로 위쪽에 두면 위로 향하는 화살표를 보면 바로 SDP를 위배하는 상태임을 알 수 있다.

### SAP

**컴포넌트는 안정된 정도만큼만 추상화되어야 한다.**

고수준 정책을 안정된 컴포넌트에 위치시키면 그 정책을 포함하는 소스 코드는 수정하기 어려워지고 시스템 전체 아키텍처가 유연성을 잃을 수 있다.  
따라서 컴포넌트가 안정되면서도 유연하게 만들 수 있을까?에 대한 질문에 대한 답은 바로 추상 클래스이다.

안정적인 컴포넌트라면 반드시 인터페이스와 추상 클래스로 구성되어 쉽게 확장할 수 있어야 한다. 따라서 의존성은 추상화의 방향으로 향하게 된다.  
다른 한편으로는 불안정한 컴포넌트는 반드시 구체 컴포넌트여야 한다고 볼 수 있다. 왜냐면 컴포넌트가 불안정하므로 컴포넌트 내부의 구체적인 코드도 쉽게 변경할 수 있어야 하기 때문이다.
클래스는 결국 추상이거나 아니거나 둘 중 하나이기에 컴포넌트 어떤 부분은 추상적이면서 다른 부분은 안정적일 수 있다.

추상화 또한 지표로 계산할 수 있다.

- Nc: 컴포넌트의 클래스 개수
- Na: 컴포넌트의 추상 클래스와 인터페이스의 개수
- A: 추상화 정도, A = Na / Nc

A가 0이면 추상 클래스가 하나도 없는 거고 1이면 전부 추상 클래스이다.

이제 I와 A 사이의 관계를 정의해보면 아래와 같다.

- I=0, A=0인 경우 매우 안정적이고 구체적이기에 추상적이지 않아 확장할 수 없고 안정적이기에 변경하기도 어렵다. 대표적인 예로 데이터 스키마를 생각할 수 있다. 변동성이 높고 극단적으로 구체적이며, 많은 컴포넌트가 여기에 의존하기 때문이다. 하지만 String 컴포넌트와 같이 변동될 가능성이 거의 없는 경우 I=0, A=0인 구역에 존재하더라도 괜찮다.
- I=1 A=1인 경우 매우 불안정하고 추상적이다. 즉 여기에 속하는 클래스들은 추상 클래스이지만 어떠한 클래스도 이를 의존하지 않는다. 이같이 쓸모없는 엔티디가 존재한다는 사실은 바람직한 상황이 아니다.

따라서 컴포넌트는 극단적인 구역이 아닌 I와A의 균형을 이루는 주계열 구역에 존재하는 것이 좋다. 이 주계열에 위치하면 자신의 안정성에 비해 너무 추상적이지 않고 추상화 정도에 비해 너무 불안정하지도 않다.  
D = |A+I-1| 지표를 통해 주계열로부터 거리를 계산할 수 있다. 따라서 이 지표를 이용해 특정하게 거리가 먼 컴포넌트의 경우 확인해 볼 필요가 있다.

### 결론

안정성 지표 I와 추상화 지표 A는 설계의 의존성과 추상화 정도가 훌륭한 패턴이라고 생각하는 수준에 얼마나 잘 부합하는지 측정한다.  
하지만 지표를 너무 맹신하지 않고 참고하는 정도로 사용해야 유용한 것을 찾을 수 있을 것이다.
