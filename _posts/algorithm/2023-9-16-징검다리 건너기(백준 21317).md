---
title: 징검다리 건너기(백준 21317)
date: 2023-09-16 22:10:00 +/-0
categories: [algorithm]
tags: [dynamic programming] # TAG names should always be lowercase
---

## 문제

| 시간 제한 | 메모리 제한 |
| --------- | ----------- |
| 1 초      | 1024 MB     |

심마니 영재는 산삼을 찾아다닌다.

산삼을 찾던 영재는 N개의 돌이 일렬로 나열되어 있는 강가를 발견했고, 마지막 돌 틈 사이에 산삼이 있다는 사실을 알게 되었다.

마지막 돌 틈 사이에 있는 산삼을 캐기 위해 영재는 돌과 돌 사이를 점프하면서 이동하며 점프의 종류는 3가지가 있다.

점프의 종류에는 현재 위치에서 다음 돌로 이동하는 작은 점프, 1개의 돌을 건너뛰어 이동하는 큰 점프, 2개의 돌을 건너뛰어 이동하는 매우 큰 점프가 있다.

각 점프를 할 때는 에너지를 소비하는데, 이 때 작은 점프와 큰 점프시 소비되는 에너지는 점프를 하는 돌의 번호마다 다르다.

매우 큰 점프는 단 한 번의 기회가 주어지는데, 이때는 점프를 하는 돌의 번호와 상관없이 k만큼의 에너지를 소비한다.

에너지를 최대한 아껴야 하는 영재가 산삼을 얻기 위해 필요한 에너지의 최솟값을 구하여라.

영재는 첫 번째 돌에서부터 출발한다.

### 입력

첫 번째 줄에는 돌의 개수 N이 주어진다.

N - 1개의 줄에 걸쳐서, 1번 돌부터 N - 1번 돌 까지의 작은 점프를 하기 위해 필요한 에너지, 큰 점프를 하기 위해 필요한 에너지가 주어진다.

마지막 줄에는 K가 주어진다.

### 출력

산삼을 얻기 위해 필요한 영재의 최소 에너지를 출력한다.

## 풀이

문제에 핵심은 매우 큰 점프에 있다.  
저장되는 필요한 에너지의 최솟값에는 이전에 매우 큰 점프를 사용한 경우와 사용하지 않은 경우를 나눠서 저장하여 매우 큰 점프에 대한 정보를 가지고 있어야 한다.
따라서 각 배열마다 매우 큰 점프를 이전에 사용했을 때 최소 값 그리고 아직 사용하지 않았을 때 최소 값을 나눠 저장한다.
그리고 아래와 같은 과정을 배열을 지나가며 반복한다.

- 작은 점프와 큰 점프의 경우 배열에 저장된 아직 매우 큰 점프를 사용하지 않은 경우의 값에 더하여 다음 칸에 값을 업데이트 해준다. 그리고 만약 이전에 매우 큰 점프를 사용하여 해당 칸에 값이 업데이트가 된 경우에만 이동하는 칸에 값을 업데이트 해준다.
- 매우 큰 점프의 경우 아직 사용하지 않은 경우에만 적용하여 이동하는 칸에 값을 업데이트 한다.

```python
N = int(input())
dp = [[10**6] * 2 for _ in range(N)]
steps = [list(map(int, input().split())) for _ in range(N - 1)]
K = int(input())

dp[0][0] = 0
for i in range(N - 1):
    small, medium = steps[i]

    if i + 1 < N:
        dp[i + 1][0] = min(dp[i + 1][0], dp[i][0] + small)
    if i + 2 < N:
        dp[i + 2][0] = min(dp[i + 2][0], dp[i][0] + medium)
    if i + 3 < N:
        dp[i + 3][1] = min(dp[i + 3][1], dp[i][0] + K)
    if dp[i][1] != 10**6:
        if i + 1 < N:
            dp[i + 1][1] = min(dp[i + 1][1], dp[i][1] + small)
        if i + 2 < N:
            dp[i + 2][1] = min(dp[i + 2][1], dp[i][1] + medium)
print(min(dp[-1]))
```

## 시간 복잡도

상수의 계산 수행을 배열 N에 대해 한번만 수행하기에 O(N)으로 볼 수 있다.

## 공간 복잡도

N\*2 크기의 배열을 사용한다.

## 어려웠던 부분

처음에 매우 큰 점프에 대한 정보를 어떻게 다룰지 몰라 어려웠다.  
dp의 경우 이전 결과로부터 저장해야 되는 정보가 어떤게 있는지 잘 파악하여 다음 결과에 사용할 수 있도록 처음에 잘 고려해야 한다.
