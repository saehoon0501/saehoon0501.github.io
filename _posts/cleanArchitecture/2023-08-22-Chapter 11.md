---
title: DIP(The Dependency Inversion Principle)
date: 2023-08-22 16:10:00 +/-0
categories: [clean_architecture]
tags: [clean_architecture.clean_architecture-chp11] # TAG names should always be lowercase
---

## DIP: The Dependency Inversion Principle

DIP에서 말하는 '유연성이 극대화된 시스템'이란 소스 코드 의존성이 추상에 의존하며 구체(concretion)에는 의존하지 않는 시스템이다.  
하지만 현실에서는 시스템은 구체적인 많은 장치에 반드시 의존하기 때문에 OS나 플랫폼 같이 안정성이 보장된 환경에 대해서는 무시하는 편이다.  
변경되지 않는다면 의존할 수 있다는 사실을 알고 있기 때문이며, 우리가 의존하지 않도록 피하고자 하는 것은 바로 변동성이 큰(volatile) 구체적인 요소다.  
그리고 이 구체적인 요소는 우리가 열심히 개발하는 중인 자주 변경될 수 밖에 없는 모듈이다.

### 안정된 추상화

소프트웨어 아키텍트라면 인터페이스를 변경하지 않고도 구현체에 기능을 추가 할 수 있는 방법을 찾기 위해 노력하며, 이는 소프트웨어 설계의 기본이다.  
결과적으로 인터페이스는 구현체보다 변동성이 낮기에 안정된 추상 인터페이스를 선호하는 아키텍처를 구상한다.  
아래와 같은 매우 구체적인 코딩 실천법으로 요약 가능하다.

- 변동성이 큰 구체 클래스를 참조하지 말자. 대신 추상 인터페이스를 참조한다.  
   이 규칙은 일반적으로 추상 팩토리를 사용하도록 강제한다.
- 변동성이 큰 구체 클래스로부터 파생하지 말자. 따라서 상속은 아주 아주 신중하게 사용한다.
- 구체 함수를 오버라이드 하지 말자. 구체 함수를 오버라이드 하면 의존성을 제거할 수 없게 되며, 실제로는 그 의존성을 상속하게 되기 때문이다.  
   차라리 추상 함수로 선언 후 구현체들에서 각자의 용도에 맞게 구현한다.
- 구체적이며 변동이 크다면 절대로 그 이름을 언급하지 말자. 이는 DIP 원칙을 다른 방식으로 풀어쓴 것이다.

### 추상 팩토리

모든 언어에서 객체를 생성하려면 해당 객체를 구체적으로 정의한 코드에 대해 소스 코드 의존성이 발생한다.  
이런 바람직하지 못한 의존성을 처리하기 위해 추상 팩토리를 사용한다.

app에서 service 인터페이스를 통해 ConcreteImpl을 사용하지만, 결국 어떤 식으로든 ConcreteImpl의 객체를 생성해야 한다. 이를 소스 코드 의존성 없이 하기 위해서는 ServiceFactory 인터페이스의 makeSvc 메서드를 호출한다. 그러면 이 인터페이스를 구현한 구현체가 대신 ConcreteImpl의 객체를 생성한 후 Service 타입으로 반환한다.

아키텍처에서 추상 컴포넌트와 구체 컴포넌트를 분리한다.

- 추상 컴포넌트는 app의 모든 고수준 업무 규칙을 포함한다.
- 구체 컴포넌트는 업무 규칙을 다루기 위해 필요한 모든 세부사항을 포함한다.

### 구체 컴포넌트

일반적으로 DIP 위배를 모두 없앨 수 없기에 적어도 DIP를 위배하는 클래스들은 적은 수의 구체 컴포넌트 내부로 모으고 시스템의 나머지 부분과 분리한다.

### 결론

DIP는 아키텍처 다이어그램에서 가장 눈에 드러나는 원칙이 될 것이다.  
의존성은 더 추상적인 엔티디가 있는 쪽으로만 향한다. 그리고 추후 이 규칙은 의존성 규칙(Dependency Rule)이라 부를 것이다.
