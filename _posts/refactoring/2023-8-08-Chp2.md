---
title: 리팩터링 원칙
date: 2023-08-08 18:10:00 +/-0
categories: [refactoring]
tags: [refactoring, refactoring-principle] # TAG names should always be lowercase
---

Refactoring Github  
<https://github.com/saehoon0501/Refactoring>

## 2장 리팩터링 원칙

---

Refactoring 전반에 적용되는 원칙을 알아본다.

### Refactoring 정의

소프트웨어의 수행 동작은 그대로 유지한 채, 코드를 이해하고 수정하기 쉽게 내부 구조를 변경하는 기법
Refactoring의 목적은 코드를 이해하고 수정하기 쉽게 만드는 것이다. 성능은 좋아질 수도 나빠질 수도 있다.

### 두 개의 모자

기능을 추가할 때는 기존 코드는 건들지 말고 새 기능을 추가하기만 한다. 그리고 Test를 작성하여 통과하는 확인하는 방식으로 진척도를 확인한다.  
Refactoirng할 때는 기능을 절대로 추가하지 않고 오로지 코드 재구성에만 전념한다. Test도 추가하거나 수정하지 않고 Interface가 바뀌었을 때만 수정한다.  
기능을 추가하다보면 코드 구조를 바꾸는게 더 작업하기 쉽다는 생각이 든다. 그러면 이때는 Refactoring 모자를 쓰고 Refactoring에만 전념한 후 다시 기능 추가 모자를 쓴다. 내가 쓰고 있는 모자를 알고 이에 따른 미묘한 작업 방식의 차이를 분명하게 인식하자.

### Refactoring 하는 이유

- 소프트웨어 설계가 좋아진다.
  설계가 나쁘면 같은 일을 하는 코드가 여러 곳에 나타나 길어진다. 이러한 중복 코드 제거는 설계 개선 작업의 중요한 한 축이다. 이를 통해 수정하는 데 드는 노력을 아낄 수 있다. 또한 모든 코드가 언제나 고유한 일을 수행함을 보장할 수 있다.
- 소프트웨어를 이해하기 쉬워진다.
  나중에 보면 무슨 코드인지 모르는 경우가 대부분이기에 코드를 이해하기 쉽게 Refactoring하여 추후 수정 시 시간을 아낄 수 있다.
- 버그를 쉽게 찾을 수 있다.
  Refactoring 과정에서 코드가 무슨일을 하는지 깊이 파악하게 되면서 새로 깨달은 것을 곧바로 코드에 반영하게 되는데 여기서부터 버그가 명확히 보이기 시작한다.
- 프로그래밍 속도를 높일 수 있다.
  처음 개발 단계에서는 좀 늦어질 수 있어도 시간이 가면서 코드가 누적되면 Refactoring을 통해 좋은 설계를 유지한 소프트웨어가 더욱 빠르게 개발될 수 있다.
  설계를 잘하고 코딩을 하는게 정설이였지만 Refactoring을 통해 지속적으로 설계를 얼마든지 개선할 수 있다.

### Refactoring은 언제 할까?

수시로 하는 Refactoring  
실수나 보기 싫은 코드 뿐 아니라 잘 작성된 코드 역시 현재 하는 작업에 적합하지 않으면 Refactoring을 수시로 진행한다.

- 새 기능을 추가 또는 버그를 잡아내기 직전: 구조를 살짝 바꾸면 다른 작업을 하기가 쉬워질 만한 부분을 찾고 중복되는 코드가 없이 새 기능을 추가한다.
- 기존 코드를 이해할 때: Refactoring을 통해 머리로 이한 것을 코드에 옮겨 담을 수 있다. 그리고 테스트를 통해 내 생각이 맞았는지 확인 가능.
- 이해하는 과정에서 비효율적인 코드를 찾았을 때: 간단히 수정할 수 있는 것은 즉시 고치고, 시간이 걸릴 꺼 같으면 먼저 하던 일을 하고 메모를 남겨 나중에 처리
  계획된 Refactoring
  지양해야하지만 그동안 Refactoring 소홀했다면 따로 시간을 잡아 Refactoring을 진행
  만약 너무 오래걸릴꺼 같으면 Refactoring을 해야할 코드와 관련된 작업을 하게 될 때마다 원하는 방향으로 조금씩 개선하자.
  만약 내부 동작을 정확히 이해하지 못했다면 먼저 이해한 후 Refactoring을 진행한다. 새로 짜는게 더 빠르겠다는 판단이 들면 Refactoring 하지 말자

Refactoring과 기능 추가를 무조건적으로 나눠서 commit한다고 좋은 것이 아니다. 때로는 이 둘이 밀접하게 엮여 전체적인 맥락 정보를 같이 가지고 있을 때도 있기 때문이다.

### Refactoring시 고려할 문제

- 새 기능 개발 속도 저하

"Refactoring의 궁극적인 목적은 개발 속도를 높여서, 더 적은 노력으로 더 많은 가치를 창출하는 것이다."  
그렇다하더라도 상황에 맞게 조율해 가면서 Refactoring과 개발을 진행한다. <- 최고의 방법은 작업하는 코드에 대해 수시로하는 작게 Refactoring을 진행

- 코드 소유권  
  때로는 Refactoring하고자하는 코드를 권한이 없거나 고객에게 API로 제공되어 쉽게 건들기 어려울 수 있다.  
  따라서 이러한 문제를 최소화하고자 코드 소유권을 팀에게 부여하자.
- Branch  
  독립적인 기능을 여러 Branch에서 각자 작업하는 시간이 길어질 수록 Master로 통합(Branch에 있는 코드와 Master를 서로 일치시킴)하기 어려워진다. 따라서 CI를 통해 하루에 최소 한 번은 Master와 통합하여 주기를 짧게 가져간다.
- Testing  
  Refactoring의 특징은 프로그램의 동작은 똑같이 유지된다는 점이다. 따라서 기존에 작성된 Test들이 모두 성공해야한다.  
  따라서 작은 단계로 점진적으로 Refactoring을 진행할 때마다 Testing을 거쳐 확인한다. 이를 통해 Error가 발생하더라도 코드 변화폭이 적기에 쉽게 찾을 수 있다.  
  Testing은 Refactoring을 가능하게 해줄 뿐만 아니라 새 기능 추가도 안전하게 진행하게 해준다. 이는 CI와도 밀접하게 연관되어 CI에 통합된 Test는 핵심이다.
- DB  
  Data migration script을 작성하고 해당 script을 통해 접근 코드와 Schema에 대한 구조적 변경을 처리하게 한다.  
  선언된 Schema나 접근 루틴을 변경하는 코드와 함께 Version 관리 시스템에 저장 후 DB를 다른 Version으로 이전할 때마다 현재 Version과 원하는 Version 사이에 있는 모든 Data migration script을 실행한다. 이렇게 전체 변경 과정을 작고 독립된 단계들로 쪼개야 migration 이후에도 정상 작동 가능하다.

### YAGNI(You Aren't Going to Need It)

항상 설계와 architecture를 완료 후 코딩을 해야한다는게 정설이였지만, 현실에는 모든 요구사항을 미리 파악하는 것이 쉽지 않다.  
따라서 현재 요구사항을 해결하는 소프트웨어를 구축 후 요구사항이 변경되면 Refactoring을 통해 architecture를 바꾼다.  
이는 처음 설계를 대충하라는 말이 아니라 처음에 너무 많은 예상 시나리오 대응하기 위해 유연성 메커니즘 등을 사용하여 복잡성을 증가 시키는 대신 추후 문제를 더 깊이 이해하게 될 때 Refactoring을 통해 점차 개선할 수 있다는 뜻이다.

### Refactoring과 성능

성능은 대부분 전체 코드 중 극히 일부에서 대부분의 시간을 소비해 저하가 온다. 따라서 먼저 코드를 다루기 쉽게 만드는데 집중한다. 그러다 성능 최적화 단계가 되면 프로파일러로 프로그램을 분석하여 시간과 공간을 많이 잡아 먹는 지점을 찾아 최적화한다. 이를 통해 영향을 주는 부분만 집중해서 최적화하기에 더 적은 노력이 들어간다.  
물론 성능을 최적화 하는 단계 또한 작게 나눠서 진행하고 매 진행 시 Testing과 프로파일러를 실행한다.
