---
title: Component Cohesion
date: 2023-08-23 17:10:00 +/-0
categories: [clean_architecture]
tags: [clean_architecture.clean_architecture-chp13] # TAG names should always be lowercase
---

## Component Cohesion

어떤 클래스를 어느 컴포넌트에 포함시켜야 할까?는 컴포넌트 응집도와 관련된 중요한 결정이므로 관련 3가지 원칙을 알아본다.

- REP: Reuse/Release Equivalence Principle(재사용/릴리스 등가 원칙)
- CCP: Common Closure Principle(공통 폐쇄 원칙)
- CRP: Common Reuse Principle(공통 재사용 원칙)

### REP

**재사용 단위는 릴리스 단위와 같다.**  
이는 소프트웨어 아키텍처 관점에서 단일 컴포넌트는 응집성이 높은 클래스와 모듈로 구성되어야 함을 뜻한다.
즉, 컴포넌트를 구성하는 모든 모듈은 서로 공유하는 중요한 테마나 목적이 있어야 한다.

이 원칙은 중요하다. 하지만 이 원칙만으로는 클래스와 모듈을 단일 컴포넌트로 묶는 방법을 제대로 설명하기 힘들기에 다른 두 원칙이 지닌 강점을 통해 보완한다. 실제로 CCP와 CRP는 REP를 엄격한 제약을 가하는 측면에서 정의한다.

### CCP

SRP에서 단일 클래스는 변경의 이유가 여러 개 있어서는 안 된다고 말하듯 CCP에서도 단일 컴포넌트는 변경의 이유가 여러 개 있어서는 안된다고 말한다.  
물리적 또는 개념적으로 강하게 결합되어 항상 함께 변경되는 클래스들을 하나의 컴포넌트에 속하게 하여 변경 모두가 단일 컴포넌트에서 발생하게 한다.  
이는 OCP에서 얻은 교훈을 확대 적용한 것으로 볼 수 있으며, 결과적으로 CCP에서는 동일한 유형의 변경에 대해 닫혀 있는 클래스들을 하나의 컴포넌트로 묶는다. 이를 통해 소프트웨어를 릴리스, 재검증, 배포하는 일과 관련된 작업량을 최소화 할 수 있다.

요약하자면  
**동일한 시점에 동일한 이유로 변경되는 것들을 한데 묶는다. 서로 다른 시점에 다른 이유로 변경되는 것들은 서로 분리한다.**

### CRP

**컴포넌트 사용자들을 필요하지 않는 것에 의존하도록 하지 않는다.**

한 컴포넌트에 속한 클래스들은 더 작게 그룹 지울 수 없으며, 같은 컴포넌트 내 클래스가 일부 클래스에만 의존하고 다른 클래스와는 독립적일 수 없음을 확인해야 한다. 따라서 CRP는 강하게 결합되지 않은 클래스들을 동일한 컴포넌트 내 한데 묶어서는 안된다고 말한다.

따라서 CRP는 ISP(인터페이스 분리 원칙)의 포괄적인 버전이다.
요약하자면  
**필요하지 않은 것에 의존하지 말라**

### 컴포넌트 응집도에 대한 균형 다이어그램

REP와 CCP는 Inclusive 원칙이기에 컴포넌트를 더욱 크게 만들며, CRP는 exclusive 원칙이기에 컴포넌트를 더 작게 만든다.  
아키텍트는 이 3가지 원칙들이 균형을 이룰 수 있도록 해야한다.

![image](../../)

REP와 CRP에만 중점을 두면 사소한 변경이 너무 많은 컴포넌트에 영향을 미친다.
CCP와 REP에만 중점을 두면 불필요한 릴리스가 너무 빈번해진다.

프로젝트 초기에는 CCP가 REP보다 중요하며 이는 개발성(developability)이 재사용성보다 더 중요하기 때문이다.  
하지만 프로젝트가 성숙해지면서 점차 REP가 더 중요해진다.  
**결국 프로젝트의 컴포넌트 구조는 프로젝트가 실제로 수행하는 일 자체보다는 시간이 지나면서 발전되고 사용되는 방법과 관련이 깊다**

### 결론

어느 클래스들을 묶어서 컴포넌트로 만들지 결정할 때, 재사용성과 개발성이라는 상충하는 힘을 고려한다.  
이들 사이에서 app의 요구에 맞게 균형을 잡는 일이 중요하며, 이러한 균형점은 유동적이기에 언제든 시간이 흐름에 따라 진화한다.
