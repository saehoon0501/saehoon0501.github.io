---
title:
date: 2023-09-28 20:50:00 +/-0
categories: [algorithm]
tags: [implementation] # TAG names should always be lowercase
---

## 문제

| 시간 제한 | 메모리 제한 |
| --------- | ----------- |
| 1 초      | 512 MB      |

길이가 N인 컨베이어 벨트가 있고, 길이가 2N인 벨트가 이 컨베이어 벨트를 위아래로 감싸며 돌고 있다. 벨트는 길이 1 간격으로 2N개의 칸으로 나뉘어져 있으며, 각 칸에는 아래 그림과 같이 1부터 2N까지의 번호가 매겨져 있다.

벨트가 한 칸 회전하면 1번부터 2N-1번까지의 칸은 다음 번호의 칸이 있는 위치로 이동하고, 2N번 칸은 1번 칸의 위치로 이동한다. i번 칸의 내구도는 A<sub>i</sub>이다. 위의 그림에서 1번 칸이 있는 위치를 "올리는 위치", N번 칸이 있는 위치를 "내리는 위치"라고 한다.

컨베이어 벨트에 박스 모양 로봇을 하나씩 올리려고 한다. 로봇은 올리는 위치에만 올릴 수 있다. 언제든지 로봇이 내리는 위치에 도달하면 그 즉시 내린다. 로봇은 컨베이어 벨트 위에서 스스로 이동할 수 있다. 로봇을 올리는 위치에 올리거나 로봇이 어떤 칸으로 이동하면 그 칸의 내구도는 즉시 1만큼 감소한다.

컨베이어 벨트를 이용해 로봇들을 건너편으로 옮기려고 한다. 로봇을 옮기는 과정에서는 아래와 같은 일이 순서대로 일어난다.

1. 벨트가 각 칸 위에 있는 로봇과 함께 한 칸 회전한다.
2. 가장 먼저 벨트에 올라간 로봇부터, 벨트가 회전하는 방향으로 한 칸 이동할 수 있다면 이동한다. 만약 이동할 수 없다면 가만히 있는다.
   1. 로봇이 이동하기 위해서는 이동하려는 칸에 로봇이 없으며, 그 칸의 내구도가 1 이상 남아 있어야 한다.
3. 올리는 위치에 있는 칸의 내구도가 0이 아니면 올리는 위치에 로봇을 올린다.
4. 내구도가 0인 칸의 개수가 K개 이상이라면 과정을 종료한다. 그렇지 않다면 1번으로 돌아간다.

종료되었을 때 몇 번째 단계가 진행 중이었는지 구해보자. 가장 처음 수행되는 단계는 1번째 단계이다.

### 입력

첫째 줄에 N, K가 주어진다. 둘째 줄에는 A<sub>1</sub>, A<sub>2</sub>, ..., A<sub>2N</sub>이 주어진다.

### 출력

몇 번째 단계가 진행 중일때 종료되었는지 출력한다.

## 풀이

각 단계를 수행할 함수로 나눠서 구현할 수 있다.

- 벨트와 로봇이 회전하는 함수: 벨트의 값들을 전부 한 칸씩 복사해 앞 칸으로 할당한다. 그리고 마지막 값을 맨 앞 칸에 할당한다. 로봇의 경우 기존에 있는 index값에 1씩 증가시킨다. 단 문제에서 N번째 칸에 도착하는 경우 무조건 로봇을 내리기 때문에 index N-2에 해당하는 로봇은 1 증가시킨 후 저장하지 않는다.

- 벨트 위의 로봇이 움직이는 함수: 로봇 index+1에 해당하는 칸의 내구도가 1 이상이고 해당 칸에 로봇이 존재하지 않으면 이동 가능하다. 이를 위해 index가 큰 로봇부터 순서대로 움직임을 처리해야 한다. 그리고 N칸에 도착하는 로봇의 경우 위 과정이 수행된 후 다시 저장되지 않는다. 만약 이동 불가능한 경우 기존 Index를 그대로 놔두고 다음 로봇으로 넘어간다.

- 벨트의 시작 위치 칸의 내구도가 1 이상이면 로봇을 추가한다. 그리고 칸의 내구도를 감소시킨다.

- 매번 벨트의 내구도 값이 바뀌는 경우 해당 내구도가 0인지 체크한 후 이를 카운트하는 과정을 거치며 위 3단계 이후 카운트 값이 K보다 커질 경우 멈추고 실행 종료한다.

```python
from collections import deque

N, K = map(int, input().split())
belt = list(map(int, input().split()))
robot = deque()

global count
count = 0


def rotate():
    i = 0
    prev = belt[i]
    while True:
        if i == 2 * N - 1:
            belt[0] = tmp
            break
        tmp = belt[i + 1]
        belt[i + 1] = prev
        prev = tmp
        i += 1

    for i in range(len(robot)):
        if robot[i] == N - 2:
            robot.pop()
            break
        robot[i] += 1
    return


def moveRobot():
    global count
    result = deque()

    while robot:
        # 가장 먼저 올려졌던 로봇 순서대로 가져온다.
        idx = robot.pop()
        # 만약 다음 칸의 내구도가 1 이상이고 로봇이 없다면
        if belt[idx + 1] > 0 and idx + 1 not in result:
            # 그 칸이 N번째 칸이면 벨트 내구도만 감소하고 로봇은 내린다.
            if idx + 1 == N - 1:
                belt[idx + 1] -= 1
            # 그 칸이 N 이전 칸이면 벨트 내구도를 감소하고 로봇의 위치를 +1 증가시켜 저장한다.
            else:
                belt[idx + 1] -= 1
                result.appendleft(idx + 1)
            # 내구도가 감소하였다면 0인지 체크하여 카운트한다.
            if belt[idx + 1] == 0:
                count += 1
        # 로봇이 이동할 수 없는 경우 로봇은 가만히 있는다.
        else:
            result.appendleft(idx)
    return result


step = 1

while True:
    rotate()
    robot = moveRobot()
    if belt[0] > 0:
        belt[0] -= 1
        robot.appendleft(0)
        if belt[0] == 0:
            count += 1
    if count >= K:
        break
    step += 1

print(step)

```

## 시간 복잡도

벨트의 크기를 N으로 본다면,  
rotate 수행은 O(N), moveRobot 수행은 O(N-1) 그리고 나머지 과정은 O(1)로 볼 수 있다.
따라서 while문에서 대략 O(2N)의 시간 복잡도를 수행하게 된다.
while문은 K가 대략 1000-2N번 반복 될 수 있다고 보면
O(N<sup>2</sup>)의 수행을 가진다. N은 최대 10<sup>2</sup>이기에 최대 10<sup>4</sup>의 수행이 되게 된다.

## 공간 복잡도

2\*N의 크기의 배열을 사용하기에 O(N)의 공간을 사용한다.

## 어려웠던 부분

문제에서 주어지는 단계들을 함수로 나눠 하나씩 따로 실행하면서 확인하면 좀더 정확히 구현할 확률이 증가한다.
