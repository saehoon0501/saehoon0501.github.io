---
title: Independence
date: 2023-08-24 14:10:00 +/-0
categories: [clean_architecture]
tags: [clean_architecture.clean_architecture-chp16] # TAG names should always be lowercase
---

좋은 아키텍처는 다음을 지원해야 한다.

- 시스템의 UseCase
- 시스템의 운영
- 시스템의 개발
- 시스템의 배포

## UseCase

아키텍처는 시스템의 행위에 큰 영향을 주지 않지만 이를 지원할 수 있다.  
지원할 수 있는 일 중 가장 중요한 사항은 행위를 명확히 하고 외부로 드러내어 시스템이 지닌 의도를 아키텍처 수준에서 알아볼 수 있게 만드는 것이다.

시스템의 Usecase 행위는 시스템의 최상위 수준에서 알아볼 수 있고 기능을 분명하게 설명하는 이름의 클래스/함수/모듈로서 아키텍처 내 핵심적인 자리를 차지할 것이다.

## 운영

시스템에서 요구되는 운영 작업을 허용할 수 있는 형태로 아키텍처를 구조화해야 한다.  
여기서 형태는 시스템에 따라 다양한 의미를 가질 수 있다.  
여러 형태:

- 처리 요소를 작은 서비스들로 배열하여 서로 다른 많은 서버에서 병렬 처리할 수 있게 만든다.
- 수많은 lightweighted 스레드가 단일 프로세서에서 같은 주소 공간을 공유하도록 만든다.
- 독립된 주소 공간에서 실행되는 소수의 프로세스들을 실행하도록 만든다.

이러한 결정은 뛰어난 아키텍트라면 열어 두어야 하는 선택사항 중 하나다.  
아키텍처에서 각 컴포넌트를 적절히 격리하여 유지하고 컴포넌트 간 통신 방식을 특정 형태로 제한하지 않는다면, 시간이 지나 운영에 필요한 요구사항이 바뀌더라도 Thread, Process, Service로 구성된 기술 스펙트럼 사이를 전환하는 일이 훨씬 쉬워질 것이다.

## 개발

**시스템을 설계하는 조직이라면 어디든지 그 조직의 의사소통 구조와 동일한 구조의 설계를 만들어 낼 것이다.**

많은 팀으로 구성되며 다양한 조직에서 시스템을 개발한다면, 팀들이 서로를 방해하지 않도록 해야 한다.  
이러한 점을 아키텍처에 반영하여 잘 격리되어 독립적으로 개발 가능한 컴포넌트 단위로 시스템을 분할하고 컴포넌트를 독립적으로 작업할 수 있게 지원해야 한다.

## 배포

좋은 아키텍처라면 시스템이 빌드된 후 즉각 배포할 수 있도록 지원해야 한다.  
이러한 아키텍처를 만들려면 시스템을 컴포넌트 단위로 적절하게 분할하고 격리시켜야 한다.  
Master 컴포넌트는 시스템 전체를 하나로 묶고, 각 컴포넌트를 올바르게 구동하고 통합 및 관리하는 역할을 하는데 이것도 여기에 포함된다.

## 선택사항 열어놓기

현실에서는 컴포넌트 구조와 관련된 관심사들 사이에서 균형을 맞추기 어렵다.  
대부분의 경우 모든 Usecase를 알 수 없으며, 운영하는데 따르는 제약사항, 팀 구조, 배포 요구사항을 알지 못하며 알고 있더라도 시스템이 생명 주기의 단계를 하니씩 거쳐감에 따라 이 사항들도 반드시 변해간다는 사실이다.

그러나 몇몇 아키텍처 원칙은 이러한 변화 속에서 사라지지 않고 균형을 맞추려는 목표점을 명확히 그릴 수 없을 때 도움이 된다.  
그리고 이러한 원칙은 좋은 아키텍처는 선택사항을 열어 둠으로써, 향후 시스템에 변경이 필요할 때 어떤 방향으로든 쉽게 변경할 수 있도록 한다.

## 계층 결합 분리

필요한 모든 Usecase를 알지는 못하지만 아키텍트는 시스템의 기본적인 의도는 분명히 알고 있기에 SRP와 OCP를 적용하여 그 의도의 맥락에 따라서 다른 이유로 변경되는 것들은 분리하고, 동일한 이유로 변경되는 것들은 묶을 수 있다.

서로 다른 이유로 변경되는 것은 무엇일까?  
UI가 변경되는 이유는 policy와는 아무련 관련이 없다. 따라서 UI 부분과 policy 부분을 서로 분리하고자 할 것이다.
policy 내에서도 app 자체와 밀접한 규칙과 도메인에 밀접한(app과 독립적인) 규칙 등 서로 다른 유형이 존재하며 각자 다른 속도로 그리고 다른 이유로 변경될 것이다.  
따라서 이 규칙들도 서로 분리하여 독립적으로 변경할 수 있도록 만들어야 한다.

DB,query language, schema 조차도 기술적인 detail이며 Policy 그리고 UI와 아무런 관련이 없다.  
결론적으로 이들을 시스템의 나머지 부분으로부터 분리하여 독립적으로 변경할 수 있도록 해야 한다.

## UseCase 결합 분리

Usecase 자체도 서로 다른 이유로 변경된다.  
주문을 삭제하는 usecase와 주문을 추가하는 usecase는 틀림없이 다른 속도로 그리고 다른 이유로 변경된다. 따라서 Usecase는 시스템을 분할하는 매우 자연스러운 방법이다.  
또한 Usecase는 시스템의 수평적인 Layer를 가로지르도록 자른 수직으로 좁다란 조각이기도 하다.  
각 Usecase마다 UI의 일부, app 특화 policy 일부, app 독립적인 policy 일부 그리고 db 일부를 사용한다. 따라서 시스템을 수평적 layer로 분할하면서 동시에 해당 layer를 가로지르는 얇은 수직적인 Usecase로 시스템을 분할할 수 있다.

결과적으로 시스템에서 서로 다른 이유로 변경되는 요소들의 결합을 분리하면 기존 요소에 지장을 주지 않고도 새로운 Usecase를 계속해서 추가할 수 있는 패턴을 볼 수 있다.  
각 Usecase를 뒷받침하는 UI와 DB를 서로 묶어서 각 Usecase가 UI와 DB의 서로 다른 관점을 사용하게 되면, 새로운 Usecase를 추가하더라도 기존 것들에 영향을 주는 일은 없을 것이다.

## 결합 분리 모드

이러한 결합 분리가 운영 관점에서 어떤 의미가 있는지 알아본다.  
Usecase에서 서로 다른 관점이 분리되었다면, 높은 처리량을 보장해야 하는 Usecase와 낮은 처리량으로도 충분한 Usecase는 분리되었다면 높은 처리량을 요구하는 Usecase는 여러 서버로 복제하여 실행할 수 있다.  
UI와 DB가 policy와 분리되어 있다면, UI와 DB는 policy와는 다른 서버에서 실행될 수 있다.

간단히 정리하면 결합 분리는 운영에도 도움이 된다. 하지만 운영 측면에서 이점을 살리기 위해서는 결합 분리를 할 때 적절한 모드를 선택해야 한다.  
분리된 컴포넌트가 서로 다른 서버에서 실행되야 하는 상황이면 이들 컴포넌트가 단일 프로세서의 동일한 주소 공간에 함께 있는 형태로 만들어져서는 안되며 독립된 서비스로써 네트워크를 통한 통신을 해야 한다.

SOA(Service-Oriented Architecture)나 Micro-Service가 좋다고 하는 것이 아니라 핵심은 때때로 컴포넌트를 서비스 수준까지도 분리해야 한다는 것이다.

이 주제를 더 논의하기 앞서 나머지 항목을 살펴보자.

## 개발 독립성

컴포넌트가 완전히 분리되면 팀 사이의 간섭은 줄어든다.  
기능 팀, 컴포넌트 팀, Layer 팀 또는 다른 형태의 팀이라도, Layer와 Usecase 결합 분리가 있는 한 아키텍처는 그 팀 구조를 뒷받침해 줄 것이다.

## 배포 독립성

Usecase와 Layer 결합 분리가 되면 배포 측면에서도 유연성이 생긴다.  
실제로 결합을 제대로 분리했다면 운영 중인 시스템에서도 Layer와 usecase를 교체하는 hot-swap이 가능하며, 새로운 Usecase를 추가하는 일은 기존 시스템에 새로운 jar 파일이나 서비스 몇 개를 추가하는 간단한 일이 된다.

## 중복

소프트웨어에서 중복은 일반적으로 나쁜 것이다. 만약 코드가 진짜 중복되었다면, 이를 줄이거나 제거해야 한다.  
하지만 중복에도 여러 종류가 있다. 진짜 중복과 우발적인 중복이다.

서로 다른 Usecase의 화면 구조가 매우 비슷하다고 했을 때 사용할 코드를 통합하고 싶을 것이다.  
하지만 이는 우발적인 중복일 가능성이 높으며, 시간이 지나면서 두 화면은 서로 다른 방향으로 분기하며 매우 다른 모습을 가질 가능성이 높다.  
만약 이러한 경우 코드를 통합하면 나중에 다시 분리하느라 큰 수고를 감수해야 한다.

Usecase를 수직으로 분리할 때 우발적인 중복에 대한 통합의 유혹을 받게 될 것이며 무조건적인 중복 제거를 조심한다.  
마찬가지로 Layer를 수평으로 분리하는 경우에도 특정 DB record의 데이터 구조가 특정 화면의 데이터 구조와 상당히 비슷하다는 점을 발견할 수도 있다. 이때 DB record와 동일한 형태의 view model을 만들어서 각 항목을 복사하는게 아니라 record 그대로 UI까지 전달하고 싶을 수 있는데 이러한 중복은 거의 확실히 우발적이다. View 모델을 만드는 것은 Layer 간 결합을 적절하게 분리하여 유지하는 데도 도움이 된다.

## 결합 분리 모드(한번 더)

Layer와 Usecase의 결합을 분리하는 방법은 다양하다.

- 소스 수준 분리 모드: 소스 코드 모듈 사이의 의존성을 제어할 수 있다. 이를 통해 하나의 모듈이 변하더라도 나머지를 재컴파일하지 않도록 만들 수 있다.
- 배포 수준 분리 모드: jar 파일, dll, 공유 라이브러리와 같이 배포 가능한 단위들 사이의 의존성을 제어할 수 있다. 많은 컴포넌트가 여전히 같은 주소 공간에 상주하며, 단순한 함수 호출을 통해 통신할 수 있다. 어떤 컴포넌트는 프로세스 간 통신, 소켓 또는 공유 메모리를 통해 통신할 수 있다. 중요한 특징은 결합이 분리된 컴포넌트가 dll, jar파일과 같이 독립적으로 배포할 수 있는 단위로 분할되어 있다는 점이다.
- 서비스 수준 분리 모드: 의존하는 수준을 데이터 구조 단위까지 낮출 수 있고 네트워크를 통해서만 통신하도록 만들 수 있다. 이를 통해 모든 실행 가능한 단위는 소스 변경에 대해 서로 완전히 독립적이게 된다.(예시로 micro-service가 있다.)

프로젝트 초기 어떤 모드가 최선일지 모르며 성숙해갈수록 최적인 모드가 달라질 수 있다.  
컴포넌트 결합 분리를 서비스가 되기 직전에 멈추는 방식을 통해 컴포너트들을 가능한 오랫동안 동일한 주소 공간에 남겨두면서 서비스에 대한 선택권을 열어 둘 수 있다. 이 방식을 통해 컴포넌트가 소스 코드 수준에서 분리된다. 그리고 개발,배포,운영에서 문제가 증가하면 서비스 수준으로 전환할 배포 단위들을 선택 후 점차적으로 서비스화 방향으로 시스템을 변경해 나아가면 된다.

좋은 아키텍처는 시스템이 monolithic 구조로 태어나 배포되더라도 이후 독립적으로 배포 가능한 단위들의 집합으로 성장하고 또 독립적인 서비스나 micro-service 수준까지 성장할 수 있도록 만들어져야 한다. 그리고 이 진행 방향을 거꾸로 되돌릴 수도 있어야 한다.

결합 분리 모드를 선택사항으로 남겨두어 배포 규모에 따라 가장 적합한 모드를 선택해 사용하자.

## 결론

결랍 분리 모드는 시간이 지나면서 바뀌기 쉬우며, 뛰어난 아키텍트라면 이러한 변경을 예측하여 큰 무리 없이 반영할 수 있도록 만들어야 한다.
