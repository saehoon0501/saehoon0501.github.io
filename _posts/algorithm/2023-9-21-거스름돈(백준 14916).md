---
title:
date: 2023-09-21 10:10:00 +/-0
categories: [algorithm]
tags: [dynamic programming, greedy] # TAG names should always be lowercase
---

## 문제

| 시간 제한 | 메모리 제한 |
| --------- | ----------- |
| 2 초      | 512 MB      |

춘향이는 편의점 카운터에서 일한다.

손님이 2원짜리와 5원짜리로만 거스름돈을 달라고 한다. 2원짜리 동전과 5원짜리 동전은 무한정 많이 가지고 있다. 동전의 개수가 최소가 되도록 거슬러 주어야 한다. 거스름돈이 n인 경우, 최소 동전의 개수가 몇 개인지 알려주는 프로그램을 작성하시오.

예를 들어, 거스름돈이 15원이면 5원짜리 3개를, 거스름돈이 14원이면 5원짜리 2개와 2원짜리 2개로 총 4개를, 거스름돈이 13원이면 5원짜리 1개와 2원짜리 4개로 총 5개를 주어야 동전의 개수가 최소가 된다.

### 입력

첫째 줄에 거스름돈 액수 n(1 ≤ n ≤ 100,000)이 주어진다.

### 출력

거스름돈 동전의 최소 개수를 출력한다. 만약 거슬러 줄 수 없으면 -1을 출력한다.

## 풀이

주어지는 금액의 크기에 맞게 배열을 선언한다.  
먼저 2원으로 만들 수 있는 모든 금액의 index에 사용된 동전의 갯수를 저장한다. 이는 먼저 2원에 1을 초기화 해주고 3원을 시작으로 배열을 지나며 -2원의 금액 위치에 동전 개수가 존재한다면 해당 값+1하며 업데이트 하면 된다.
5원에서는 먼저 5원에 1을 초기화 후 6원을 시작으로 -1 위치에 동전 개수가 존재한다면 그 값 + 1을 저장한다.

```python
dp = [-1] * 100001

dp[2] = 1
for i in range(3, 100001):
    if dp[i - 2] != -1:
        dp[i] = dp[i - 2] + 1

dp[5] = 1
for i in range(6, 100001):
    if dp[i - 5] != -1:
        dp[i] = dp[i - 5] + 1
n = int(input())
print(dp[n])
```

## 시간 복잡도

n 크기의 배열에 O(n) 작업을 두 번 시행한다.

## 공간 복잡도

n 크기의 배열을 한번 선언하였다.

## 어려웠던 부분

처음에 이 문제가 왜 greedy에 포함되는지 이해가 되지 않았지만 모든 금액을 만들 수 있는 동전의 최소 개수는 항상 더 큰 동전이 사용되었을 때 경우로 업데이트 하면되기에 greedy에 포함되는 것으로 이해하였다.
