---
title: Structured Programming
date: 2023-08-21 19:10:00 +/-0
categories: [clean_architecture]
tags: [clean_architecture.clean_architecture-chp4] # TAG names should always be lowercase
---

## Structured Programming

### 증명

프로그래머는 입증된 구조를 이용하고, 이들 구조를 코드와 결합시켜 코드가 올바르다는 사실을 스스로 증명하게 되는 방식인 유클리드 계층구조를 가능케하려는 시도가 있었다.  
이를 위해 모듈을 더 작은 단위로 재귀적으로 분해하는 과정에서 goto문이 방해가 되었고, 이 모듈을 분해할 수 없다면 증명에 필수적인 기법인 Divide n Conquer가 불가능했다.  
반면 goto문이 if와while과 같은 분기와 반복이라는 제어 구조에서 사용될 경우 문제가 되지 않았다. 그리고 모듈이 이러한 종류의 제어 구조만을 사용한다면 증명 가능한 단위로까지 모듈을 재귀적으로 세분화하는 것이 가능해 보였다.  
모든 프로그램을 Sequence, Selection, Iteration이라는 3가지 구조만으로 표현할 수 있다는 사실이 증명되었다. 그리고 이 3가지는 모듈을 증명 가능케하는 바로 그 제어 구조였기에 제어구조의 최소 집합이 동일하다는 사실로부터 구조적 프로그래밍이 탄생하였다.

### 해로운 성명서

이 성명서를 통해 goto문장을 사용하지 않게 되었다. 그래서 현재 우리 모두 구조적 프로그래머이며, 제어흐름을 제약 없이 직접 전환할 수 있는 선택권 자체를 언어에서 제공하지 않는다.

### 기능적 분해

구조적 프로그래밍을 통해 모듈을 증명 가능한 더 작은 단위로 재귀적으로 분해할 수 있게 되었고, 결국 모듈을 기능적으로 분해할 수 있음을 뜻했다.  
따라서 고수준의 기능들을 분해하여 저수준의 함수들로 분해하고 이를 더 작은 것들로 분해가 가능하다. 이렇게 하면 모듈 -> 컴포넌트 -> 더 작은 기능들로 세분화가 된다.

### 과학

끝내 수학적으로 프로그램을 증명하는 것은 실패했고 이 대신 과학 관점에서 **사실임을 증명하는 것 대신 서술이 틀렸음을 증명하는 방식**을 프로그래밍에서 사용했다.

### 테스트

테스트를 통해 프로그램이 맞다고 증명할 수 없지만 목표에 부합할 만큼은 충분히 참이라고 여길 수 있게 한다.  
따라서 소프트웨어 개발은 수학적인 시도가 아닌 과학과 같다.  
따라서 구조적 프로그래밍을 통해 프로그램을 증명 가능한 세부 기능 집합으로 재귀적으로 분해하고 테스트를 통해 증명 가능한 세부 기능들이 거짓인지 증며하려고 시도한다.

### 결론

구조적 프로그래밍이 현재까지 가치 있는 이유는 프로그래밍에서 반증 가능한 단위를 만들어 낼 수 있는 능력 때문이다.(그래서 이제 goto문을 볼 수 없게됨)  
이에 맞춰 소프트웨어에서는 모듈, 컴포넌트, 서비스가 반증 가능하도록(테스트하기 쉽게) 만들어야 한다.
