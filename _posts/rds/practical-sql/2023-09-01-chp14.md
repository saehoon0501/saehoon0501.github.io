---
title: Mining Text to Find Meaningful Data
date: 2023-09-01 13:10:00 +/-0
categories: [rds]
tags: [practical-sql-chp14] # TAG names should always be lowercase
image: ../../assets/practical-sql/practical-sql.jpeg
---

# 문자열 함수를 사용하여 텍스트 서식 지정하기

## 대소문자 형식

- upper(string): string을 모두 대문자로 만든다.
- lower(string): string을 모두 소문자로 만든다.
- initcap(string): 각 단어의 첫 글자를 대문자로 만든다.

## 문자 정보

- char_length(string): string의 길이를 반환한다.
- length(string): PostgreSQL 전용 char_length
- position(substring in string): substring이 string 내 몇 번째 문자열에 위치하는지 알려준다.

## 문자 삭제하기

- trim(char from string): string내에 있는 char를 삭제한다. 만약 제거할 문자를 지정하지 않으면 모든 공백을 제거한다. PostgreSQL 전용 ltrim 또는 rtrim을 통해 문자열의 왼쪽 또는 오른쪽 끝에서 문자를 제거할 수 있다.

## 문자 추출하고 대체하기

- left(string, number): 왼쪽에서 시작해 number만큼 문자를 추출하여 반환한다.
- right(string, number): 오른쪽에서 시작해 number만큼 문자를 추출하여 반환한다.
- replace(string, from, to): string에 있는 from 문자를 to 문자로 대체한다.

# 정규식을 사용하여 텍스트 패턴 매칭하기

정규식(regular expressions,regex)는 텍스트 패턴을 설명하는 표기 언어 유형이다.  
WHERE 절에 이를 활용해 특정 텍스트 패턴에 일치하는 행에 대해서만 작업을 수행할 수 있다.

## 정규식 표기법

| 식     | 설명                                                                                                    |
| ------ | ------------------------------------------------------------------------------------------------------- |
| .      | 개행문자를 제외한 모든 문자를 찾는 와일드카드                                                           |
| [FGz]  | 대괄호 안의 모든 문자. 여기에서는 F,G 또는 z이다.                                                       |
| [a-z]  | 문자 범위, a부터 z까지 소문자를 의미한다.                                                               |
| [^a-z] | 대괄호 안 캐럿은 제외를 의미힌다. 여기서는 a부터 z까지 소문자를 제외한 나머지에서 일치이다.             |
| \w     | 모든 단어 문자 또는 언더바. [A-Za-z0-9]와 동일하다.                                                     |
| \d     | 모든 숫자                                                                                               |
| \s     | 공백 한 개                                                                                              |
| \t     | tab 문자                                                                                                |
| \n     | 줄바꿈 문자                                                                                             |
| \r     | 캐리지 리턴 문자                                                                                        |
| ^      | 문자열의 시작 부분에서 일치                                                                             |
| $      | 문자열의 끝에서 일치                                                                                    |
| ?      | ? 앞에 있는 문자 또는 그룹 항목을 0 또는 1회인 경우 일치                                                |
| \*     | \* 앞에 있는 문자 또는 그룹 항목을 0 이상인 경우 일치                                                   |
| +      | + 앞에 있는 문자 또는 그룹 항목을 1회 이상인 경우 일치                                                  |
| {m}    | 앞에 있는 문자 또는 그룹 항목이 m회인 경우에만 일치                                                     |
| {m,n}  | 앞에 있는 문자 또는 그룹 항목이 m과 n 사이 횟수인 경우에만 일치                                         |
| a\|b   | 파이프는 or을 나타낸다. 여기서는 a 또는 b를 찾는다.                                                     |
| ()     | 캡처 그룹을 생성하는 방법으로 일치하는 결과에서 원하는 부분만 가져오고 싶을 때 해당 부분을 ()로 감싼다. |
| (?:)   | 캡처 그룹을 생성하지 않고 문자 집합 또는 표현식을 그룹으로 일치하는 것을 찾는다.                        |

The game starts at 7 p.m. on May 2, 2024. 문자열에 대한 정규식 예

| 식              | 일치하는 내용                                 | 결과                                                      |
| --------------- | --------------------------------------------- | --------------------------------------------------------- | ------ |
| .+              | 임의의 문자를 한 번 이상                      | The game starts at 7 p.m. on May 2, 2024.                 |
| \d{1,2} (?:a.m. | p.m.)                                         | 한/두 자리 숫자 뒤에 공백 후 a.m. 또는 p.m.이 오는 문자열 | 7 p.m. |
| ^\w+            | 시작 부분에 하나 이상의 단어 문자             | The                                                       |
| \w+.$           | 끝에 임의의 문자가 오는 하나 이상의 단어 문자 | 2024.                                                     |
| May             | June                                          | May 또는 June이라는 단어 중 하나                          | May    |
| \d{4}           | 숫자 4자리                                    | 2024                                                      |
| May \d, \d{4}   | May 숫자, 숫자 4자리                          | May 2, 2024                                               |

## WHERE와 함께 정규식 사용하기

WHERE 절에서 LIKE 및 ILIKE를 사용하여 Query를 필터링했는데 여기에 Regex를 활용한다.  
regex에서 ~를 사용하여 대소문자를 구분하고 ~\*를 사용하여 대소문자를 구분하지 않는 필터링을 수행한다.  
앞에 !를 추가하여 두 식을 모두 부정할 수도 있다.

```sql
SELECT county_name
FROM us_counties_pop_est_2019
WHERE county_name ~* 'ash' AND county_name !~'Wash'
ORDER BY county_name;
```

대소문자 구분하지 않는 필터링을 수행하여 ash를 포함하지만 Wash는 포함하지 않는 주 이름만 가져온다.

## 텍스트를 바꾸거나 분할하는 정규식 함수

```sql
SELECT regexp_replace('05/12/2024', '\d{4}','2023');
SELECT regexp_split_to_table('Four, score, and, seven, years, age', ',');
SELECT regexp_split_to_array('Phil Mike Tony Steve', ' ');
```

regexp_replace는 패턴에 일치하는 부분을 대체 텍스트로 바꿔준다.  
regexp_split_to_table은 문자열에서 패턴에 의해 구분된 텍스트를 행으로 분할한다.  
regexp_split_to_array는 문자열에서 패턴에 의해 구분된 텍스트를 문자열 배열로 만들어 준다.

## 정규식 함수를 사용하여 텍스트를 데이터로 변환하기

보고서에 있는 텍스트들을 가져와 정규식 함수를 사용해 데이터를 가져온다.

### 범죄 보고서 날짜 패턴 매칭하기

```sql
SELECT crime_id,
        regexp_match(original_text, '\d{1,2}\/\d{1,2}\/\d{1,2}')
FROM crime_reports
ORDER BY crime_id;
```

보고서에서 두 자리 숫자/두 자리 숫자/두 자리 숫자 패턴을 가지는 날짜를 데이터로 추출한다.
regexp_match()는 기본적으로 첫 번째 일치 항목을 반환한다. 그리고 결과를 배열 또는 요소 목록으로 반환하기에 중괄호에 묶여서 나오게 된다.

### 두 번째 날짜가 존재하는 경우 두 번째 날짜 매칭하기

이를 위해서 regexp_matches() 함수를 사용하고 플래그 g를 옵션으로 전달한다.

```sql
SELECT crime_id,
        regexp_matches(original_text, '\d{1,2}\/\d{1,2}\/\d{1,2}', 'g')
FROM crime_reports
ORDER BY crime_id;
```

그 결과로 crime_id가 1인 사건의 두 날짜가 표시된다.

만약 두 번째 날짜만 가져오고 싶다면 - 다음에 오는 패턴을 활용해 날짜 앞에 - 포함하는 패턴을 만들면 된다.  
하지만 -는 timestamp에서 잘못된 형식이기에 패턴에는 사용하되 결과에는 반영하지 않도록 ()로 캡처 그룹을 지정한다.

```sql
SELECT crime_id,
        regexp_match(original_text, '-(\d{1,2}\/\d{1,2}\/\d{1,2})')
FROM crime_reports
ORDER BY crime_id;
```

### 추가 범죄 신고 요소 매칭하기

- 첫 번째 시간 \/\d{2}\n(\d{4}): 날짜가 \두 자리 숫자 이후 줄 바꿈 다음에 시간이 오는 것을 이용해 패턴을 작성하였고 일치하는 패턴 중 마지막 숫자 4자리만 결과로 가져온다.
- 두 번째 시간 \/\d{2}\n\d{4}-(\d{4}): 첫 번째 시간 다음 -으로 오는게 두 번째 시간이기에 이를 패턴에 그대로 반영하였고 마지막 숫자 4자리만 결과로 가져온다.
- 거리 hrs.\n(\d+ .+(?: Sq.|Plz.|Dr.|Ter.|Rd.)): hrs. 다음 줄 바꿈으로 오는게 거리이다. 그리고 거리는 항상 숫자로 시작한 다음 어떠한 문자들을 나열하다가 마지막에 같은 단어로 끝나는 것을 패턴으로 반영하였다. 결과에서는 hrs.\n을 제외한 부분만 가져온다.
- 도시 (?:Sq.|Plz.|Dr.|Ter.|Rd.)\n(\w+ \w+|\w+)\n: 항상 특정 단어로 시작한 다음 줄을 바꾸면 도시 텍스트 정보가 나오는 것을 활용한다. 도시 텍스트는 단어 단어 형식 또는 단어 형식을 가진다. 그리고 그 단어 부분만 결과로 가져온다.
- 범죄 유형 \n(?:\w+ \w+|\w+)\n(.\*):: 도시 다음으로 오는 모든 단어와 : 사이의 문자열들을 범죄 유형 데이터로 가져온다.
- 설명 :\s(.+)(?:C0|S0): 범죄 유형 뒤의 :과 사건 번호 사이에 있다. 따라서 이를 그대로 반영한 패턴을 작성하였다.
- 사건 번호 (?:C0|S0)[0-9]+: C0 또는 S0로 시작하는 숫자들을 패턴으로 만들어 찾는다.

### 추출된 데이터로 테이블 업데이트하기

```sql
UPDATE crime_reports
SET date_1 =
    (
      (regexp_match(original_text, '\d{1,2}\/\d{1,2}\/\d{2}'))[1]
          || ' ' ||
      (regexp_match(original_text, '\/\d{2}\n(\d{4})'))[1]
          ||' US/Eastern'
    )::timestamptz,

    date_2 =
    CASE
    -- if there is no second date but there is a second hour
        WHEN (SELECT regexp_match(original_text, '-(\d{1,2}\/\d{1,2}\/\d{2})') IS NULL)
                     AND (SELECT regexp_match(original_text, '\/\d{2}\n\d{4}-(\d{4})') IS NOT NULL)
        THEN
          ((regexp_match(original_text, '\d{1,2}\/\d{1,2}\/\d{2}'))[1]
              || ' ' ||
          (regexp_match(original_text, '\/\d{2}\n\d{4}-(\d{4})'))[1]
              ||' US/Eastern'
          )::timestamptz

    -- if there is both a second date and second hour
        WHEN (SELECT regexp_match(original_text, '-(\d{1,2}\/\d{1,2}\/\d{2})') IS NOT NULL)
              AND (SELECT regexp_match(original_text, '\/\d{2}\n\d{4}-(\d{4})') IS NOT NULL)
        THEN
          ((regexp_match(original_text, '-(\d{1,2}\/\d{1,2}\/\d{2})'))[1]
              || ' ' ||
          (regexp_match(original_text, '\/\d{2}\n\d{4}-(\d{4})'))[1]
              ||' US/Eastern'
          )::timestamptz
    END,
    street = (regexp_match(original_text, 'hrs.\n(\d+ .+(?:Sq.|Plz.|Dr.|Ter.|Rd.))'))[1],
    city = (regexp_match(original_text,
                           '(?:Sq.|Plz.|Dr.|Ter.|Rd.)\n(\w+ \w+|\w+)\n'))[1],
    crime_type = (regexp_match(original_text, '\n(?:\w+ \w+|\w+)\n(.*):'))[1],
    description = (regexp_match(original_text, ':\s(.+)(?:C0|SO)'))[1],
    case_number = (regexp_match(original_text, '(?:C0|SO)[0-9]+'))[1];
```
