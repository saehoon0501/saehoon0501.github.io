---
title: What Is Architecture?
date: 2023-08-24 12:10:00 +/-0
categories: [clean_architecture]
tags: [clean_architecture.clean_architecture-chp15] # TAG names should always be lowercase
---

소프트웨어 아키텍처란 시스템을 컴포넌트로 분할하는 방법, 분할된 컴포넌트를 배치하는 방법, 컴포넌트가 서로 의사소통하는 방식에 따라 정해진다.  
그리고 그 형태는 아키텍처 안에 담긴 소프트웨어 시스템이 쉽게 개발,배포,운영,유지보수되도록 만들어진다.  
**이러한 일을 용이하게 만들기 위해서는 가능한 많은 선택지를 오래 남겨두는 전략을 따라야 한다.**

아키텍처가 시스템이 제대로 동작하도록 지원하는 것은 피상적인 것이지, 능동적이거나 본질적인 것은 아니다.  
본질적인 것은 시스템의 수명과 관련된 비용을 최소화하고, 프로그래머의 생산성을 최대화하는데 있다.

## 개발

개발하기 힘든 시스템이라면 수명이 길지도 건강하지도 않을 것이기에 아키텍처는 개발팀들이 시스템을 쉽게 개발할 수 있도록 뒷받침해야 한다.  
팀 규모에 따라 아키텍처 관련 결정에서도 차이가 난다. 만약 팀이 작은 규모이면 monolithic 시스템을 개발할 수 있지만 팀의 규모가 클 수록 안정된 인터페이스를 갖춘, 잘 설계된 컴포넌트 단위로 분리가 필수적이다.

## 배포

아키텍처는 시스템을 단 한 번에 쉽게 배포할 수 있도록 만드는데 그 목표를 두어야 한다.  
하지만 대대분 초기 개발 단계에서는 배포 전략을 거의 고려하지 않기에 개발하기는 쉬울지 몰라도 배포하기는 상당히 어려운 아키텍처가 만들어진다.
예를 들어 Micro Service Architecture를 사용할 경우 컴포넌트 경계가 매우 뚜렷해지고 인터페이스가 대체로 안정화되므로 매우 쉽게 개발할 수 있을 것으로 판단할 수 있다.  
하지만 배포 단계에서 엄청나게 늘어난 Micro Service들을 서로 연결하기 위해 설정하고 작동 순서를 결정하는 과정이 오작동 발생의 원천이 될 수 있다.

## 운영

아키텍처가 운영에 미치는 영향은 개발,배포,유지보수에 미치는 영향은 덜하다.  
운영에서 겪는 대다수의 어려움은 아키텍처에는 극적인 영향을 주지 않고 단순히 하드웨어를 더 투입해서 해결할 수 있다.

그렇더라도 시스템을 운영할 때 아키텍처는 시스템을 운영하는 데 필요한 요구도 알려준다.  
Use case, 기능, 시스템의 필수 행위를 First-class Entity로 격상시키고, 이들 요소가 개발자에게 주요 목표로 인식되도록 해준다.

## 유지보수

시스템에서 비용이 가장 많이 드는 측면이다.  
기존 시스템에 새로운 기능을 추가하거나 결함을 수정할 때 파헤쳐서 어디를 고치는 게 최선인지, 그리고 어떤 전략을 쓰는게 최적일지 결정할 때 드는 비용이다.  
시스템을 컴포넌트로 분리하고, 안정된 인터페이스를 두어 서로 격리하여 미래에 추가될 기능에 대해 열린 아키텍처를 만들면 이 비용을 크게 줄일 수 있다.

## 선택사항 열어 두기

소프트웨어의 유연성은 시스템의 형태, 컴포넌트의 배치 방식, 컴포넌트가 상호 연결되는 방식에 상당히 크게 의존한다.  
여기서 열어 둬야할 선택 사항이란 중요치 않은 detail을 말한다.

시스템은 크게 정책(Policy)와 detail 두 가지로 구분하여 볼 수 있는데, 정책 요소는 모든 업무 규칙과 업무 절차를 구체화하는 가장 큰 가치를 지닌 곳이다.  
세부사항은 사람, 외부 시스템, 프로그래머가 정책과 소통할 때 필요한 요소지만, 정책이 가진 행위에는 조금도 영향을 미치지 않는다. Ex) IO 장치, DB, server, framework 등  
아키텍트의 목표는 시스템에서 정책을 가장 핵심적인 요소로 식별하고 동시에 세부사항은 정책에 무관하게 만들 수 있는 형태의 시스템을 구축하는데 있다.  
이를 통해 세부사항을 결정하는 일은 미룰 수 있게 된다. 그러면 더 많은 정보를 얻을 수 있고, 기초로 제대로된 결정을 내릴 수 있다.

**좋은 아키텍트는 결정되지 않은 사항의 수를 최대화한다.**

## 장치 독립성

만약 프린터를 제어하는 입출력 명령어를 직접 사용해서 코드를 작성한다면 장치 종속성(device dependent)가 생겨 추후 다른 장치로 이전하는 경우 프로그램을 전부 다시 작성하여야 한다.  
현재 OS는 입출력 장치를 소프트웨어 함수로 추상화했고 프로그램에서 OS의 서비스를 호출하면 추상화된 장치를 처리한다. 그러면 동일한 프로그램을 아무런 변경 없이 여러 장치에서 사용할 수 있다.

## 광고 우편

장치 독립성을 가진 형태는 정책을 세부사항으로부터 분리한 형태이며 어떤 장치를 사용할지에 대한 결정을 미루는 것이다.  
이를 통해 어떤 장치를 사용할지 전혀 모른채, 그리고 고려하지 않고도 프로그램을 작성할 수 있다.

## 물리적 주소 할당

만약 프로그램에서 디스크의 상세 구조를 알고 모두 하드코딩 되어 있다면, 나중에 구조가 업그레이드된 디스크를 사용할 시 이전의 디스크에서 과거 데이터를 읽어 들여 새로운 디스크로 기록하는 특수한 프로그램을 작성해야 한다. 즉 detail에 매우 의존하는 형태이다.  
대신 디스크를 거대한 선형 배열로 취급하고 디스크의 물리적 구조를 알고 있는 변환 루틴을 작성을 통해 시스템에서 고수준의 정책이 디스크의 물리적 구조로부터 독립되도록 수정한다.  
그러면 디스크 드라이브 구조에 대한 결정사항을 app으로부터 분리할 수 있게 된다.

## 결론

이 장에 포함된 이야기는 소규모 사례이지만, 그 원칙은 아키텍트가 대규모 시스템에 적용할 수 있는 예이기도 하다.  
좋은 아키텍트는 세부사항을 정책으로부터 신중하게 가려내고, 정책이 세부사항과 결합되지 않도록 엄격하게 분리한다. 이를 통해 정책은 세부사항에 대한 어떠한 지식도 갖지 못하게 되며, 어떤 경우에도 세부사항에 의존하지 않게 된다.  
**세부사항에 대한 결정을 가능한 오랫동안 미룰 수 있는 방향으로 정책을 설계하자.**
