---
title: 데이터 조직화
date: 2023-08-15 18:10:00 +/-0
categories: [refactoring]
tags: [refactoring, refactoring-organizingdata] # TAG names should always be lowercase
---

## 9장 데이터 조직화

데이터 구조에 집중한 Refactoring들을 살펴보자.

나오는 기법들:

- 변수 쪼개기
- 필드 이름 바꾸기
- 파생 변수를 질의 함수로 바꾸기
- 참조를 값으로 바꾸기
- 값을 참조로 바꾸기
- 매직 리터럴 바꾸기

### 변수 쪼개기

배경  
역할이 둘 이상인 변수는 예외없이 역할 당 하나의 변수로 쪼갠다. 여러 용도로 사용되는 변수는 코드를 읽는 이에게 큰 혼란을 주기 때문이다.
여기서 변수에는 매개변수도 포함된다는 사실을 기억한다.(함수에 데이터를 전달하는 용도와 결과를 호출자에 반환하는 용도를 나눈다.)  
절차

1. 변수를 선언한 곳과 값을 처음 대입하는 곳에서 변수이름을 바꾼다.
   이후 대입이 항상 I = i +<무언가> 형태라면 수집 변수이므로 쪼개면 안된다. 수집 변수는 총합 계산, 문자열 연결, 스트림에 스기, 컬렉션에 추가하기 등의 용도로 흔히 쓰인다.
2. 가능하면 이때 immutable로 선언한다.
3. 이 변수에 두 번째로 값을 대입하는 곳 앞까지의 모든 참조를 새로운 변수 이름으로 바꾼다.
4. 두 번째 대입 시 변수를 원래 이름으로 다시 선언한다.
5. 테스트
6. 반복한다. 매 반복에서 변수를 새로운 이름으로 선언하고 다음번 대입 때까지의 모든 참조를 새 변수명으로 바꾼다. 이 과정을 마지막 대입까지 반복한다.

### 필드 이름 바꾸기

배경  
데이터 구조는 코드를 이해하는 열쇠이다. 따라서 이를 제일 잘 반영하는 데이터의 이름을 사용해야 한다. 클래스에서 getter와 setter도 클래스 사용자 입장에서는 필드와 다를 바 없다. 따라서 똑같이 getter와 setter의 이름도 중요하다.  
절차

1. 레코드의 유효 범위가 제한적이라면 필드에 접근하는 모든 코드를 수정한 후 테스트한다. 이후 단계는 필요없다.
2. 유효 범위가 넓은 경우 레코드가 캡슐화되지 않았다면 우선 레코드를 클래스로 캡슐화한다.
3. 캡슐화된 객체 안의 private 필드명을 변경하고 그에 맞게 내부 메서드들을 수정한다.
4. 테스트
5. 생성자의 매개변수 중 필드와 이름이 겹치는 게 있다면 '함수 선언 바꾸기'로 변경한다.
6. 접근자들의 이름도 바꿔준다.

### 파생 변수를 질의 함수로 바꾸기

배경  
가변 데이터는 연쇄 효과로 인해 찾기 어려운 문제를 야기할 수 있어 유효 범위를 가능한 좁혀야 한다.
이에 대한 좋은 방법으로는 값을 쉽게 계산해낼 수 있는 변수들은 모두 제거하고 계산 결과를 리턴하는 질의 함수로 바꾼다.
예외의 경우는 불변 데이터를 기반으로 새로운 데이터 구조를 생성하는 변형 연산이라면 계산 결과 또한 일정하기에 계산 코드로 대체할 수 있어도 그대로 두는 것이 좋다.

만약 소스 데이터가 가변이고 파생 데이터 구조의 수명을 관리해야 하는 상황에서는 객체를 사용하는 편이 유리하다. 불변일 경우 객체를 사용하던 속성으로 사용하던 상관없다.  
절차

1. 변수 값이 갱신되는 지점을 모두 찾는다. 필요하면 변수 쪼개기를 활용해 각 갱신 지점에서 변수를 분리한다.
2. 해당 변수의 값을 계산해주는 함수를 만든다.
3. 해당 변수가 사용되는 모든 곳에 어셔션을 추가하여 함수의 계산결과가 변수의 값과 같은지 확인한다.
   필요하면 변수 캡슐화하기를 적용하여 어서션이 들어갈 장소를 마련해준다.
4. 테스트
5. 변수를 읽는 코드를 모두 함수 호출로 대체한다.
6. 테스트
7. 변수를 선언하고 갱신하는 코드를 죽은 코드 제거하기로 없앤다.

### 참조를 값으로 바꾸기

배경  
객체를 다른 객체에 중첩하면 내부 객체를 참조 혹은 값으로 취급할 수 있다. 참조냐 값이냐의 차이는 내부 객체의 속성을 갱신하는 방식에서 잘 드러난다. 참조로 다루는 경우에는 내부 객체는 그대로 둔 채 그 객체의 속성만을 갱신하며, 값으로 다루는 경우에는 새로운 속성을 담은 객체로 기존 내부 객체를 통째로 대체한다.
참조를 값으로 바꾸면 그 값이 몰래 바뀌어 내부에 영향을 줄지 걱정하지 않아도 된다. 따라서 값 객체는 분산 시스템과 동시성 시스템에서 특히 유용하다.
만약 특정 객체를 여러 객체에서 공유하고자 한다면, 이는 참조로 해야 나중에 공유 객체의 값을 변경했을 때 관련 객체들이 모두 알 수 있다.  
절차

1. 후보 클래스가 불변인지 혹은 불변이 될 수 있는지 확인한다.
2. 각각의 setter를 하나씩 제거한다.
3. 이 값 객체의 필드들을 사용하는 동치성(Equality) 비교 메서드를 만든다.
   동치성 비교 메서드를 override할 때 보통 해시코드 생성 메서드도 함께 override해야 함을 유의한다.
   Javascript에서는 이러한 동치성 비교 메서드를 지원하지 않으니 직접 작성하자

### 값을 참조로 바꾸기

배경  
논리적으로 같은 데이터를 물리적으로 복제해 사용할 때 그 데이터가 갱신되면 모든 복제본을 찾아서 빠짐없이 갱신해야 하는 경우가 존재한다. 따라서 이러한 경우 복제된 데이터들을 모두 참조로 바꿔주는게 좋다.
값을 참조로 바꾸면 Entity 하나당 객체도 단 하나만 존재하게 되는데, 이러면 객체들을 한데 모아놓고 Client의 접근을 관리해주는 일종의 Container가 필요해진다. 그리고 나중에 객체가 필요한 곳에서는 모두 이 Container로부터 얻어 쓰는 방식이된다.(Dependency Injection)  
절차

1. 같은 부류에 속하는 객체들을 보관할 container를 만든다.(이미 있다면 생략)
2. 생성자에서 이 부류의 객체들 중 특정 객체를 정확히 찾아내는 방법이 있는지 확인한다.
3. 호스트 객체의 생성자들을 수정하여 필요한 객체를 이 container에서 찾도록 한다. 하나 수정할 때마다 테스트

### 매직 리터럴 바꾸기

배경  
매직 리터럴이란 소스 코드에 등정하는 일반적인 리터럴 값을 말한다. 코드를 읽는 사람이 만약 이 값의 의미를 모른다면 리터럴 값 자체로는 의미를 명확하게 알려주지 못하므로 매직 리터럴이라 한다. 따라서 필요하다 생각되는 경우 이러한 리터럴 값을 의미를 나타내는 변수명에 저장하여 사용한다.
'매직 리터럴 바꾸기'의 필요성은 해당 리터럴 값의 유효 범위가 크고 맥락 정보가 없을 때 크게 강조된다.  
절차

1. 상수를 선언하고 매직 리터럴을 대입한다.
2. 해당 리터럴이 사용되는 곳을 모두 찾는다.
3. 찾은 곳 각각에서 리터럴이 새 상수와 똑같은 의미로 사용되었는지 확인하여, 같은 의미라면 상수로 대체한 후 테스트한다.
