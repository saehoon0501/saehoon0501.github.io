---
title: Components
date: 2023-08-23 15:10:00 +/-0
categories: [clean_architecture]
tags: [clean_architecture.clean_architecture-chp12] # TAG names should always be lowercase
---

SOLID 원칙이 벽돌을 배치하는 방법을 알려준다면, 컴포넌트 원칙은 빌딩에 방을 배치하는 방법을 설명해준다.  
소프트웨어 컴포넌트가 무엇인지, 컴포넌트를 구성하는 요소는 무엇인지, 컴포넌트를 결합하여 시스템을 구성하는 방법에 대해 알아보자.

## Components

컴포넌트는 시스템의 구성 요소로 배포할 수 있는 가장 작은 단위다. 그리고 여러 컴포넌트를 서로 링크하여 실행 가능한 단일 파일로 생성할 수 있다.

### 컴포넌트의 간략한 역사

프로그래밍 초창기에는 프로그램을 로드할 메모리의 위치를 정하는 일이 프로그래머가 가장 먼저 결정해야 하는 사항 중 하나였다.  
그리고 라이브러리 함수의 소스 코드를 app 코드에 직접 포함시켜 단일 프로그램으로 컴파일했다. 하지만 메모리는 너무 작아서 컴파일러는 소스 코드를 여러 차례 읽어야 했다.
이는 너무 오래걸렸기에 라이브러리를 개별적으로 컴파일하고 이에 대한 심벌 테이블을 생성 후 app을 컴파일 했다. 그리고 app을 실행할 때 바이너리 라이브러리를 로드한 다음 app을 로드했다.
하지만 이마저도 app이 점점 커졌기에 결국 추가 공간을 할당해야 했고 메모리 단편화는 계속될 수 밖에 없었다.

### 재배치성

해결책은 재배치가 가능한 바이너리(relocatable binary)였다.  
지능적인 로더를 사용해서 메모리에 재배치할 수 있는 형태의 바이너리를 생성하도록 컴파일러를 수정하였고 프로그래머는 라이브러리를 로드할 위치와 app을 로드할 위치를 로더에게 지시할 수 있게 되었다. 이를 통해 오직 필요한 함수만을 로드할 수 있게 되었다.  
또한 컴파일러에서 재배치 가능한 바이너리 안의 함수 이름을 metadata형태로 생성하여 만약 프로그램이 라이브러리 함수를 호출하면 이를 외부 참조로 생성했고 라이브러리 함수를 정의하는 쪽에서는 해당 함수 이름을 외부 정의로 생성했다.  
즉 로더가 외부 참조를 외부 정의에 링크시킬 수 있게된 링킹 로더가 나오게 된 것이다.

### 링커

이제 프로그램을 개별적으로 컴파일하고 로드할 수 있는 단위로 분할할 수 있게 되었다. 하지만 프로그램이 커지면서 링킹 로더가 너무 느려지게 되었다.  
따라서 마침내 로드와 링크를 두 단계로 분리하여 링커는 링크가 완료된 재배치 코드를 만들어 주었고 그 덕분에 로더의 로딩 과정이 아주 빨라졌다.  
이제 한번 만들어둔 실행 파일은 언제라도 빠르게 로드할 수 있게 되었다.

이 또한 결국 시간이 지나면서 느려지게 되지만 이젠 하드웨어의 성장이 프로그램의 성장보다 더 빨랐기에 링크 시간이 줄어드는 시간이 더 빨라지기 시작했다.  
결국 오늘날에는 기존 app에 plugin 형태로 배포하는 것이 일상적인 일이 되었다.

### 결론

Runtime에 plugin형태로 결합할 수 있는 동적 링크 파일이 이 책에서 말하는 소프트웨어 컴포넌트에 해당한다. 예전에는 이를 위해 엄청난 노력이 필요했지만 이젠 너무나 쉽게 컴포넌트 plugin 아키텍처를 적용할 수 있다.
