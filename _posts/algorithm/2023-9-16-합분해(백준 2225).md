---
title: 합분해(백준 2225)
date: 2023-09-16 14:10:00 +/-0
categories: [algorithm]
tags: [dynamic programming] # TAG names should always be lowercase
---

## 문제

| 시간 제한 | 메모리 제한 |
| --------- | ----------- |
| 2 초      | 128 MB      |

0부터 N까지의 정수 K개를 더해서 그 합이 N이 되는 경우의 수를 구하는 프로그램을 작성하시오.

덧셈의 순서가 바뀐 경우는 다른 경우로 센다(1+2와 2+1은 서로 다른 경우). 또한 한 개의 수를 여러 번 쓸 수도 있다.

### 입력

첫째 줄에 두 정수 N(1 ≤ N ≤ 200), K(1 ≤ K ≤ 200)가 주어진다.

### 출력

첫째 줄에 답을 1,000,000,000으로 나눈 나머지를 출력한다.

## 풀이

숫자 N을 정수 K개를 더해 만들 수 있는 경우를 dp[N][K]라고 한다. 숫자들은 0~N까지로 주어진다.  
이 경우 dp[N][K]는 숫자 N을 사용해서 만든 경우, N-1을 사용해서 만든 경우, N-2, ... , 1을 사용해서 만든 경우들의 합으로 볼 수 있다.
따라서 점화식을 세우면, dp[N][K] = dp[N-1][K-1] +... + dp[0][K-1]로 볼 수 있다.

```python
N, K = map(int, input().split(" "))
dp = [[0] * (K + 1) for _ in range(N + 1)]

for i in range(N + 1):
    dp[i][1] = 1

for i in range(N + 1):
    for j in range(2, K + 1):
        for k in range(i + 1):
            dp[i][j] += dp[k][j - 1]

print(dp[N][K] % 1_000_000_000)
```

## 시간 복잡도

for loop에서 수행되는 계산과정은 O(N<sup>2</sup>K)이 나오게 된다.

## 공간 복잡도

선언 되는 배열의 크기는 N\*K를 사용하게 된다.

## 어려웠던 부분

N개의 수에서 K개를 고르는 방법들 의 수는 N을 선택하는 경우의 수와 선택하지 않는 경우의 수로 나눠 dp[N][K] = dp[N-1][K] + dp[N-1][K-1]로 볼 수 있다. 하지만 이 문제에서는 N개의 수에서 K개를 골라 N 합을 가지는 경우를 고려해야 하며, 순서가 다른 경우 다르게 취급하고 같은 수를 여러 번 쓸 수 있다. 따라서 K가 1인 경우를 제외 모든 경우 0~N까지 존재하는 수들을 다 한번씩 고른 경우 N 합을 가지는 경우들의 합을 통해 결과를 도출할 수 있다.
만약 문제에서 순서가 다른 경우를 같게 취급하였다면 0~N 숫자 중간에서 계산 과정을 끝내 중복을 피해야 했을 것이다.
