---
title: 가장 긴 짝수 연속한 부분 수열(백준 22857)
date: 2023-09-17 18:10:00 +/-0
categories: [algorithm]
tags: [dynamic programming] # TAG names should always be lowercase
---

## 문제

| 시간 제한 | 메모리 제한 |
| --------- | ----------- |
| 1 초      | 1024 MB     |

길이가 N인 수열 S가 있다. 수열 S는 1 이상인 정수로 이루어져 있다.  
수열 S에서 원하는 위치에 있는 수를 골라 최대 K번 삭제를 할 수 있다.

예를 들어, 수열 S가 다음과 같이 구성되어 있다고 가정하자.

수열 S : 1 2 3 4 5 6 7 8  
수열 S에서 4번째에 있는 4를 지운다고 하면 아래와 같다.  
수열 S : 1 2 3 5 6 7 8  
수열 S에서 최대 K번 원소를 삭제한 수열에서 짝수로 이루어져 있는 연속한 부분 수열 중 가장 긴 길이를 구해보자.

### 입력

수열 S의 길이 N와 삭제할 수 있는 최대 횟수인 K가 공백으로 구분되어 주어진다.

두 번째 줄에는 수열 S를 구성하고 있는 N개의 수가 공백으로 구분되어 주어진다.

### 출력

수열 S에서 최대 K번 원소를 삭제한 수열에서 짝수로 이루어져 있는 연속한 부분 수열 중 가장 긴 길이를 출력한다.

## 풀이

주어지는 수열에서 짝수 번째 수들 자리에 해당 짝수를 포함하는 최대 부분 수열의 길이를 저장한다.  
여기서 핵심은 짝수 칸에 최대 부분 수열의 길이 뿐만 아니라 해당 부분 수열에서 몇 번의 삭제 횟수가 남았는지 저장하는 것이다.  
최대 부분 수열의 길이를 업데이트 하는 과정은 다음과 같다.

- 해당하는 짝수 칸에서 시작해 이전 칸들의 숫자들을 확인한다.
- 만약 이전 칸의 값이 홀수이면 count 값을 증가 시킨다.
- 만약 짝수이면 해당 칸에 저장된 최대 부분 수열의 남은 삭제 횟수가 현재 count값보다 더 클 경우 현재 칸의 값에 이전 칸의 최대 부분 수열의 길이를 더해주고 작업을 끝낸다. 하지만 만약 count값보다 더 작은 경우 이전 칸의 부분 수열을 사용할 수 없기에 현재 칸에 +1을 수행 후 짝수 칸들의 카운팅을 계속 진행한다.
- 만약 count가 주어진 K보다 더 커지거나 배열 끝자리까지 수행된 경우 수행되는 과정을 멈춘다.

```python
N, K = map(int, input().split())
numbers = list(map(int, input().split()))
dp = [[0] * 2 for _ in range(N)]

for i in range(N):
    if numbers[i] % 2 == 0:
        dp[i] = [1, K]

        count = 0
        for j in range(i - 1, -1, -1):
            if K < count:
                break
            if numbers[j] % 2 == 0:
                if count <= dp[j][1]:
                    dp[i][0] += dp[j][0]
                    dp[i][1] = dp[j][1] - count
                    break
                else:
                    dp[i][0] += 1
                    dp[i][1] = K - count
            else:
                count += 1

result = 0
for val, count in dp:
    result = max(result, val)
print(result)
```

## 시간 복잡도

배열의 매 짝수 칸마다 이전 칸들을 끝까지 지나가며 계산을 수행하기에 최악의 경우 O(N<sup>2</sup>)의 결과가 나오게 된다.

## 공간 복잡도

N\*2의 크기의 공간을 사용하게 된다.

## 어려웠던 부분

이전 칸의 가장 긴 짝수 부분 수열의 결과를 단순히 가져오는 경우만 고려하고 만약 남은 삭제 횟수가 이전 칸까지 도달할 때 사용된 삭제 횟수보다 더 적은 경우를 놓쳐 이 경우에 계산을 수행하지 않아 해당 칸의 값이 단순히 1이 나와 문제를 틀리게 되었다.  
배열에는 해당 짝수 칸을 포함하는 최대 부분 수열을 항상 가지는 Greedy 방식임을 유의한다.
