---
title: Boundary Anatomy
date: 2023-08-24 17:10:00 +/-0
categories: [clean_architecture]
tags: [clean_architecture.clean_architecture-chp18] # TAG names should always be lowercase
---

시스템 아키텍처는 일련의 소프트웨어 컴포넌트와 그들을 분리하는 경계에 의해 정의된다.  
그리고 이러한 경계는 다양한 형태로 나타난다.

## 경계 횡단하기

런타임에 경계를 횡단한다는 말은 경계 한쪽에 있는 기능에서 반대편 기능을 호출하여 데이터를 전달하는 일을 의미한다.  
그리고 적절한 위치에서 경계를 횡단하게 하는 비결은 소스 코드 의존성 관리에 있다.  
왜냐하면 소스 코드 모듈 하나가 변경되면, 이에 의존하는 다른 소스 코드 모듈도 변경하거나 재컴파일해서 새로 배포해야 할지도 모르기 때문이다.  
경계는 이러한 변경이 전파되는 것을 막는 방화벽을 구축하고 관리하는 수단이다.

## 두려운 단일체

가장 단순하며 흔한 형태로, 함수와 데이터가 단일 프로세서에서 같은 주소 공간을 공유하며 그저 나름의 규칙에 따라 분리되어 있을 뿐이다.  
배포 관점에서는 이는 monolith라 불리는 단일 실행 파일일 뿐이다.

그렇다 해서 단일체 경계가 실제로 존재하지 않거나, 경계 자체가 무의하다는 뜻은 아니다.  
최종적으로 정적으로 링크된 단일 실행 파일을 만들더라도 그 안에 포함된 다양한 컴포넌트를 개발하고 바이너리로 만드는 과정을 독립적으로 수행할 수 있게 하는 일은 대단히 가치 있다.  
이러한 아키텍처의 경우 거의 모든 경우에 동적 다형성에 의존하며 내부 의존성을 관리한다. 따라서 OOP가 아주 중요한 패러다임이 될 수 있었던 것이다.

가장 단순한 형태의 경계 횡단은 저수준 detail에서 고수준 서비스로 향하는 함수 호출이다.  
이와 같은 규칙적인 방식으로 구조를 분리하면 컴포넌트를 독립적으로 작업할 수 있기에 매우 큰 도움이 된다.

단일체를 배포하는 일은 일반적으로 컴파일과 정적 링크 작업을 수반하므로 이러한 시스템에서 컴포넌트는 소스 코드 형태로 전달된다.

## 배포형 컴포넌트

아키텍처의 경계가 물리적으로 드러날 수 있는데 그중 가장 단순한 형태는 dll, 자바 jar 파일과 같은 동적 링크 라이브러리다.  
컴포넌트를 이 형태로 배포하면 따로 컴파일하지 않고 곧바로 사용할 수 있다. 대신 컴포넌트는 바이너리와 같이 배포 가능한 형태로 전달된다.  
따라서 배포 작업은 단순히 배포 가능한 단위를 좀 더 편리한 형태로 묶는 일에 지나지 않는다.

이러한 배포 과정에서 차이만 날 뿐 배포 수준의 컴포넌트는 단일체와 동일하다. 일반적으로 모든 함수가 동일한 프로세서와 주소 공간에 위치하며 컴포넌트를 분리하거나 컴포넌트 간 의존성을 관리하는 전략도 단일체와 동일하다.  
동적 링크와 런타임 로딩으로 최초의 함수 호출은 오래 걸릴 수 있지만, 대체로 경계를 가로지르는 통신은 빈번할 것이다.

## 스레드

스레드는 아키텍처 경계도 배포 단위도 아니다.  
실행 계획과 순서를 체계화하는 방법에 가깝다. 모든 스레드가 단 하나의 컴포넌트에 포함될 수 있고 많은 컴포넌트에 걸쳐 분산될 수 있기 때문이다.

## 로컬 프로세스

좀더 강한 물리적 경계를 띠는 형태이다.  
로컬 프로세스들은 동일한 프로세서 또는 하나의 멀티코어 시스템에 속한 여러 프로세서들에서 실행되지만 각각이 독립된 주소 공간에서 실행된다.  
보통 socket이나 message queue와 같이 OS에서 제공하는 통신 기능을 이용하여 서로 통신한다.

각 로컬프로세스는 정적으로 링크된 단일체거나 동적으로 링크된 여러개의 컴포넌트로 구성될 수 있다.  
즉 로컬프로세스는 일종의 최상위 컴포넌트로 컴포넌트 간 의존성을 동적 다형성을 통해 관리하는 저수준 컴포넌트들로 구성된다 볼 수 있다.

로컬 프로세스 분리 전략은 이전 경우와 동일하기에 의존성의 방향은 항상 고수준 컴포넌트를 향한다. 즉 로컬 프로세스에서는 고수준 프로세스가 저수준 프로세스의 이름, 물리 주소, 레지스트리 조회 키를 절대로 포함해서는 안된다.  
저수준 프로세스가 고수준 프로세스의 plugin이 되도록 만드는 것이 아키텍처 관점의 목표라는 것을 명심한다.

경계를 지나는 통신에는 OS 호출, 데이터 marshalling, 프로세스 간 문맥 교환 등이 있으며 제법 비싼 작업에 속하기에 통신이 너무 빈번하게 이뤄지지 않도록 신중하게 제한해야 한다.

## 서비스

가장 강력한 물리적인 경계를 가진 형태이다. 서비스는 자신의 물리적 위치에 구애받지 않기에 물리적으로 동일한 프로세서나 멀티코에서 동작할 수도 있고 아닐 수도 있다. 서비스들은 모든 통신이 네트워크를 통해 이뤄진다고 가정한다.

서비스에서는 경계를 지나는 통신이 매우 느리기에 빈번한 통신을 자제해야 하며 latency에 따른 문제를 고수준에서 처리할 수 있어야 한다.  
이를 제외하면 로컬 프로세스에 적용한 규칙이 그대로 적용된다. 고수준 서비스의 소스에는 저수준 서비스를 특정 짓는 어떤 물리적인 정보(예로 URI)를 절대로 포함해서는 안된다는 뜻이다.

서비스는 상호작용하는 일련의 로컬 프로세스 Facade에 불과할 때도 많다.

## 결론

단일체를 제외한 대다수의 시스템은 한 가지 이상의 경계 전략을 사용한다.  
개별 서비스 또는 로컬 프로세스는 거의 언제나 소스 코드 컴포넌트로 구성된 단일체이거나 혹은 동적으로 링크된 배포형 컴포넌트의 집합이다.  
즉, 한 시스템 안에서도 통신이 빈번한 로컬 경계와 지연이 중요하게 고려되야 하는 경계가 혼합되어 있음을 의미한다.
